# 第10章：软件工程 - 知识提纲与重难点

## 📊 章节概况
- **考试重要性**：⭐⭐⭐⭐⭐
- **考试频率**：极高（每年12-15分）
- **建议学习时间**：12-15小时
- **主要题型**：选择题、综合应用题、计算题

---

## 🎯 核心知识点框架

### 1. 软件工程概述 ⭐⭐⭐

#### 1.1 软件开发生命周期（传统）

**软件定义时期：**
- 问题定义
- 可行性研究
- 需求分析

**软件开发时期：**
- 概要设计
- 详细设计
- 编码
- 测试

**软件运行和维护：**
- 移交用户使用

#### 1.2 软件工程过程（PDCA）⭐⭐⭐⭐

**P (Plan) - 软件规格说明：**
- 规定软件功能及运行限制

**D (Do) - 软件开发：**
- 开发满足规格说明的软件

**C (Check) - 软件确认：**
- 确认软件满足用户需求

**A (Action) - 软件演进：**
- 运行中不断改进满足新需求

#### 1.3 软件系统工具分类 ⭐⭐⭐⭐

**软件开发工具：**
- 需求分析工具
- 设计工具
- 编码与排错工具
- 测试工具

**软件维护工具：**
- 版本控制工具
- 文档分析工具
- 开发信息库工具
- 逆向工程工具
- 再工程工具

**软件管理和支持工具：**
- 项目管理工具
- 配置管理工具
- 软件评价工具
- 软件开发工具的评价和选择

#### 1.4 软件设计四个活动
- 数据设计
- 架构（体系结构）设计
- 人机界面（接口）设计
- 过程设计

---

### 2. 能力成熟度模型 ⭐⭐⭐⭐⭐

#### 2.1 CMM（能力成熟度模型）⭐⭐⭐⭐⭐

| 等级 | 名称 | 特点 | 关键过程域 |
|------|------|------|------------|
| 1 | 初始级 | 杂乱无章、混乱<br>依赖个人英雄 | 无 |
| 2 | 可重复级 | 建立基本项目管理<br>可重复成功经验 | 软件配置管理<br>软件质量保证<br>软件子合同管理<br>软件项目跟踪与监督<br>软件项目策划<br>软件需求管理 |
| 3 | 已定义级 | 管理和工程过程文档化<br>标准化<br>综合成标准软件过程 | 同行评审<br>组间协调<br>软件产品工程<br>集成软件管理<br>培训大纲<br>组织过程定义<br>组织过程焦点 |
| 4 | 已管理级 | 制定详细度量标准<br>定量理解和控制 | 软件质量管理<br>定量过程管理 |
| 5 | 优化级 | 加强定量分析<br>持续改进 | 过程更改管理<br>技术改革管理<br>缺陷预防 |

**记忆口诀：** "初可已已优" 或 "1混2重3定4管5优"

#### 2.2 CMMI（能力成熟度模型集成）⭐⭐⭐⭐⭐

**阶段式模型（5个成熟度等级）：**

| 等级 | 名称 | 特点 | 关键过程域数量 |
|------|------|------|----------------|
| 1 | 初始级 | 不可预测、缺乏控制 | 无 |
| 2 | 已管理级 | 过程为项目服务 | 7个 |
| 3 | 已定义级 | 过程为组织服务 | 13个 |
| 4 | 定量管理级 | 过程已度量和控制 | 2个 |
| 5 | 优化级 | 集中于过程改进和优化 | 2个 |

**已管理级（2级）过程域：** ⭐⭐⭐⭐⭐
- 需求管理
- 项目计划
- 配置管理
- 项目监督与控制
- 供应商合同管理
- 度量和分析
- 过程和产品质量保证

**已定义级（3级）过程域：** ⭐⭐⭐⭐
- 需求开发
- 技术解决方案
- 产品集成
- 验证
- 确认
- 组织级过程焦点
- 组织级过程定义
- 组织级培训
- 集成项目管理
- 风险管理
- 集成化的团队
- 决策分析和解决方案
- 组织级集成环境

**定量管理级（4级）过程域：**
- 组织级过程性能
- 定量项目管理

**优化级（5级）过程域：**
- 组织级改革与实施
- 因果分析和解决方案

**连续式模型：**
- 关注每个过程域的能力
- 不同过程域可达到不同能力等级

---

### 3. 软件过程模型 ⭐⭐⭐⭐⭐

#### 3.1 瀑布模型（SDLC）⭐⭐⭐⭐⭐

**阶段：**
1. 可行性分析（计划）
2. 需求分析
3. 软件设计（概要设计、详细设计）
4. 编码（含单元测试）
5. 测试
6. 运行维护

**特点：** ⭐⭐⭐⭐⭐
1. 从上一项活动接受输入
2. 实施该项活动应完成的工作
3. 给出工作成果作为输出传给下一项
4. 对工作成果进行评审
5. 尽量减少多个阶段间的反复
6. 以较小费用开发软件

**适用场景：**
- 需求明确、清晰
- 功能有较清晰定义
- 对交付时间有严格要求

**关键字记忆：** "需求明确"、"功能清晰"

#### 3.2 螺旋模型 ⭐⭐⭐⭐

**特点：**
- 演化软件过程模型
- 结合原型迭代特征和瀑布模型系统化方面
- 软件开发是一系列增量发布
- 强调风险分析

**四个象限（周期性重复）：**
1. 制订计划
2. 风险分析 ⭐⭐⭐⭐⭐
3. 实施工程
4. 客户评估

**适用场景：**
- 庞大而复杂的系统
- 高风险系统
- 大型软件开发

**关键字记忆：** "风险驱动"、"大型复杂"

#### 3.3 原型化模型 ⭐⭐⭐⭐

**特点：**
- 创建快速原型
- 与干系人交互
- 充分讨论和分析
- 弄清系统需求
- 在原型基础上开发

**原型应具备：**
1. 实际可行
2. 具有最终系统基本特征
3. 构造方便、快速、造价低

**特点：**
- 对用户需求动态响应
- 逐步纳入需求

#### 3.4 增量模型 ⭐⭐⭐⭐

**特点：**
- 首先开发核心模块功能
- 与用户确认
- 再开发次核心模块
- 每次开发一部分功能
- 优先级最高的服务最先交付

**与原型区别：**
- 增量模型每次增量版本可作为独立可操作作品
- 原型构造一般为了演示

**难点：**
- 如何将客户需求划分为多个增量

#### 3.5 其他模型 ⭐⭐⭐

**喷泉模型：**
- 以用户需求为动力
- 以对象作为驱动
- 适合面向对象开发方法
- 具有迭代性和无间隙性

**基于构件的开发模型（CBSD）：**
- 利用预先包装的构件构造应用系统
- 增强复用性
- 构建构件库供其他系统复用
- 提高可靠性、节省时间和成本

**形式化方法模型：**
- 建立在严格数学基础上
- 生成计算机软件形式化的数学规格说明

---

### 4. 敏捷模型 ⭐⭐⭐⭐⭐

#### 4.1 敏捷开发宣言 ⭐⭐⭐⭐⭐

**四大价值观：**
1. **个体和交互** 胜过 过程和工具
2. **可工作的软件** 胜过 面面俱到的文档
3. **客户合作** 胜过 合同谈判
4. **响应变化** 胜过 遵循计划

#### 4.2 敏捷方法特点 ⭐⭐⭐⭐

**两个特点：**
1. **适应性** 而非 预设性
2. **面向人** 而非 面向过程

**核心思想：**
1. 敏捷方法是适应型，拥抱变化
2. 以人为本，发挥人的特性
3. 迭代增量式开发过程

#### 4.3 主要敏捷方法 ⭐⭐⭐⭐

**极限编程（XP）：** ⭐⭐⭐⭐⭐
- 基础和价值观：交流、朴素、反馈、勇气
- 近螺旋式开发方法
- 将复杂开发过程分解为简单小周期
- 提倡测试先行

**水晶系列方法：**
- 以人为中心理念
- 提倡"机动性"方法
- 包含共性核心元素

**并列争球法（Scrum）：**
- 迭代的增量化过程
- 每段时间（如30天）一次迭代称为"冲刺"（Sprint）
- 按需求优先级实现产品
- 多个自组织小组并行递增实现

**特性驱动开发（FDD）：**
- 迭代开发模型
- 三要素：人、过程、技术
- 五个核心过程：
  1. 开发整体对象模型
  2. 构造特征列表
  3. 计划特征开发
  4. 特征设计
  5. 特征构建

---

### 5. 统一过程模型（RUP）⭐⭐⭐⭐⭐

#### 5.1 RUP九个核心工作流 ⭐⭐⭐⭐⭐

**工程类工作流：**
1. **业务建模**：理解机构及商业运作
2. **需求**：定义系统功能及用户界面
3. **分析与设计**：把需求转化为分析设计模型
4. **实现**：把设计模型转换为实现结果
5. **测试**：检查子系统交互、集成
6. **部署**：打包、分发、安装软件

**支持类工作流：**
7. **配置与变更管理**：跟踪维护制品完整性和一致性
8. **项目管理**：提供计划、人员分配、执行、监控指导
9. **环境**：提供软件开发环境

#### 5.2 RUP四个阶段 ⭐⭐⭐⭐⭐

**初始阶段：**
- 定义最终产品视图和业务模型
- 确定系统范围

**细化阶段：**
- 设计及确定系统体系结构
- 制订工作计划及资源要求

**构造阶段：**
- 构造产品
- 继续演进需求、体系结构、计划
- 直至产品提交

**移交阶段：**
- 把产品提交给用户使用

#### 5.3 RUP核心概念 ⭐⭐⭐⭐

**角色（Who）：**
- 描述某个人或小组的行为与职责
- 如：体系结构师、设计人员、实现人员、测试员、配置管理人员

**活动（How）：**
- 有明确目的的独立工作单元

**制品（What）：**
- 活动生成、创建或修改的一段信息

**工作流（When）：**
- 有意义的连续活动序列
- 产生有价值的产品
- 显示角色之间关系

#### 5.4 RUP特点 ⭐⭐⭐⭐⭐

**1. 用例驱动：**
- 需求分析、设计、实现、测试都是用例驱动

**2. 以体系结构为中心：** ⭐⭐⭐⭐⭐
- 4+1视图模型：
  - **用例视图**：分析人员和测试人员关心（系统行为）
  - **逻辑视图**：最终用户关心（系统功能）
  - **实现视图**：程序员关心（配置、装配）
  - **进程视图**：系统集成人员关心（性能、可伸缩性、吞吐率）
  - **部署视图**：系统工程师关心（发布、安装、拓扑结构）

**3. 迭代与增量：**
- 把整个项目分为多个迭代过程
- 每次迭代考虑系统一部分需求
- 进行分析、设计、实现、测试、部署
- 每次迭代在已完成部分基础上进行
- 每次增加新功能实现

---

### 6. 逆向工程 ⭐⭐⭐⭐

#### 6.1 软件复用
- 将已有软件的各种知识用于建立新软件
- 缩减软件开发和维护资源
- 提高软件生产力和质量

**复用内容：**
- 领域知识
- 开发经验
- 设计决定
- 体系结构
- 需求、设计、代码、文档

#### 6.2 逆向工程 ⭐⭐⭐⭐⭐

**定义：**
- 分析程序
- 在比源代码更高抽象层次上建立程序表示
- 设计的恢复过程

**四个级别：** ⭐⭐⭐⭐⭐
1. **实现级**：抽象语法树、符号表、过程设计表示
2. **结构级**：调用图、结构图、程序和数据结构
3. **功能级**：数据和控制流模型
4. **领域级**：E-R模型

**特点：**
- 领域级：抽象级别最高，完备性最低
- 实现级：抽象级别最低，完备性最高

#### 6.3 相关概念 ⭐⭐⭐⭐⭐

**重构：**
- 在同一抽象级别上转换系统描述形式

**设计恢复：**
- 借助工具从已有程序中抽象出设计信息
- 包括：数据设计、总体结构设计、过程设计

**再工程：** ⭐⭐⭐⭐⭐
- 在逆向工程基础上
- 修改或重构已有系统
- 产生系统新版本
- 包括三个步骤：
  1. 逆向工程
  2. 新需求考虑过程
  3. 正向工程

**正向工程：**
- 从现有系统恢复设计信息
- 使用该信息改变或重构现有系统
- 改善整体质量

---

### 7. 需求工程 ⭐⭐⭐⭐⭐

#### 7.1 软件需求定义 ⭐⭐⭐⭐

**定义：**
- 用户对系统在功能、行为、性能、设计约束等方面的期望
- 用户解决问题或达到目标所需的条件或能力

**需求工程两大过程：**
1. 需求开发
2. 需求管理

#### 7.2 需求分类 ⭐⭐⭐⭐⭐

**业务需求：**
- 反映企业或客户对系统高层次目标要求
- 来自项目投资人、客户、市场营销部门、产品策划部门
- 确定项目视图和范围

**用户需求：**
- 描述用户具体目标
- 用户要求系统必须能完成的任务
- 描述用户能使用系统做什么
- 通过用户访谈和问卷调查获取

**系统需求：** ⭐⭐⭐⭐⭐
从系统角度说明软件需求，包括：

1. **功能需求（行为需求）：**
   - 规定开发人员必须实现的软件功能
   - 用户利用这些功能完成任务、满足业务需要

2. **非功能需求：**
   - 系统必须具备的属性或品质
   - 软件质量属性（可维护性、可靠性、效率等）
   - 其他非功能需求

3. **设计约束（限制条件、补充规约）：**
   - 对系统的约束说明
   - 如：必须采用国有自主知识产权数据库
   - 必须运行在UNIX操作系统下

#### 7.3 需求获取 ⭐⭐⭐⭐⭐

**定义：**
- 确定和理解不同项目干系人需求和约束的过程

**常见方法：**

**1. 用户访谈：** ⭐⭐⭐⭐⭐
- 1对1至1对3
- 有代表性的用户
- 形式：结构化和非结构化
- 优点：灵活性好、应用范围广
- 缺点：信息量大、记录困难、需要领域知识

**2. 问卷调查：**
- 用户多，无法一一访谈时使用

**3. 采样：** ⭐⭐⭐⭐
- 从种群中系统选出代表性样本
- 公式：样本数量 = 0.25 × (可信度因子 / 错误率)²
- 基于数理统计原理
- 可减少数据收集偏差

**4. 情节串联板：**
- 一系列图片讲故事

**5. 联合需求计划（JRP）：** ⭐⭐⭐⭐
- 联合各个关键用户代表
- 系统分析师、开发团队代表一起
- 通过有组织会议讨论需求
- 高度组织的群体会议

**6. 需求记录技术：**
- 任务卡片
- 场景说明
- 用户故事
- Volere白卡

#### 7.4 需求分析 ⭐⭐⭐⭐⭐

**好的需求特性：**
- 无二义性
- 完整性
- 一致性
- 可测试性
- 确定性
- 可跟踪性
- 正确性
- 必要性

**需求分析任务：**
1. 绘制系统上下文范围关系图
2. 创建用户界面原型
3. 分析需求可行性
4. 确定需求优先级
5. 为需求建立模型
6. 创建数据字典
7. 使用QFD（质量功能部署）

#### 7.5 结构化需求分析 ⭐⭐⭐⭐⭐

**特点：**
- 自顶向下
- 逐步分解
- 面向数据

**三大模型：**
1. **功能模型**：数据流图（DFD）
2. **行为模型**：状态转换图
3. **数据模型**：E-R图
4. **数据字典**（DD）

#### 7.6 数据流图（DFD）⭐⭐⭐⭐⭐

**基本图形元素：**

**1. 外部实体：**
- 系统外部的人或组织
- 数据的源点或终点

**2. 加工（处理）：**
- 描述输入数据流到输出数据流的变换
- 数据流必须经过加工

**3. 数据存储：**
- 用来存储数据

**4. 数据流：**
- 由一组固定成分的数据组成
- 表示数据的流向

**常见错误：** ⭐⭐⭐⭐⭐
1. **黑洞**：有输入但没有输出
2. **奇迹**：有输出但没有输入
3. **灰洞**：输入不足以产生输出

#### 7.7 数据字典（DD）⭐⭐⭐⭐

**定义：**
- 为数据流图中各成分做出说明
- 包括：数据流、数据项、数据存储、基本加工

**符号含义：** ⭐⭐⭐⭐⭐

| 符号 | 含义 | 举例 |
|------|------|------|
| = | 被定义为 | x = a + b |
| + | 与（组成） | x由a和b组成 |
| [a\|b] | 或（选择） | x由a或b组成 |
| {a} | 重复 | x由0个或多个a组成 |
| () | 可选 | x = a + (b) |

**加工逻辑描述方法：**
- 结构化语言
- 判定表
- 判定树

#### 7.8 需求定义（SRS）⭐⭐⭐⭐⭐

**软件需求规格说明书（SRS）：**
- 需求开发活动的产物
- 项目干系人与开发团队共同理解的基础
- 整个开发工作的基础
- 软件开发过程中最重要的文档之一

**需求定义方法：**

**1. 严格定义（预先定义）：**
- 所有需求都能被预先定义
- 开发人员与用户能准确清晰交流
- 图形或文字可充分体现最终系统

**2. 原型方法：**
- 迭代的循环型开发方式
- 并非所有需求都能预先准确说明
- 原型提供克服交流困难的手段
- 需要实际可供用户参与的系统模型
- 反复是完全需要和值得提倡的

#### 7.9 需求验证（需求确认）⭐⭐⭐⭐

**目的：**
- 与用户一起确认需求无误
- 对SRS进行评审和测试

**两个步骤：**

**1. 需求评审：**
- 正式评审
- 非正式评审

**2. 需求测试：**
- 设计概念测试用例

**需求基线：**
- 通过验证后的SRS
- 请用户签字确认
- 作为验收标准之一
- 不可随意更新
- 更改必须走需求变更流程

#### 7.10 需求管理 ⭐⭐⭐⭐⭐

**定义需求基线：**
- 通过评审的需求说明书
- 变更需求需按流程进行

**需求状态变化：**
- 已提出 → 已批准 → 已实现 → 已验证

**需求变更和风险：**

**变更产生原因：**
- 外部环境变化
- 需求和设计不够完整
- 新技术出现
- 公司机构重组造成业务流程变化

**带有风险的做法：**
- 无足够用户参与
- 忽略用户分类
- 用户需求不断增加
- 模棱两可的需求
- 不必要的特性
- 过于精简的SRS
- 不准确的估算

**变更控制委员会（CCB）：** ⭐⭐⭐⭐
- 也称配置控制委员会
- 任务：
  - 对建议的配置项变更做出评价
  - 审批变更
  - 监督已批准变更的实施

#### 7.11 需求跟踪 ⭐⭐⭐⭐⭐

**双向跟踪：**

**正向跟踪：**
- 用户原始需求是否都实现了
- 检查需求到实现的映射

**反向跟踪：**
- 软件实现的是否都是用户要求的
- 不多不少
- 检查实现到需求的映射

**需求跟踪矩阵：** ⭐⭐⭐⭐⭐

| 用例 | UC-1 | UC-2 | UC-3 | ... | UC-n |
|------|------|------|------|-----|------|
| FR-1 | ✓ | | | | |
| FR-2 | | ✓ | ✓ | | |
| ... | | | | | |
| FR-n | | | | | ✓ |

**分析：**
- 某行都没有✓：原始需求未实现（正向跟踪发现问题）
- 某列都没有✓：有多余功能（反向跟踪发现问题）

---

### 8. 系统设计 ⭐⭐⭐⭐⭐

#### 8.1 系统设计概述

**主要目的：**
- 为系统制定蓝图
- 在各种技术和实施方法中权衡利弊
- 精心设计
- 合理使用各种资源
- 勾画新系统详细设计方法

**设计方法：**
- 结构化设计方法
- 面向对象设计方法

**主要内容：**
- 概要设计
- 详细设计

**概要设计基本任务：** ⭐⭐⭐⭐
- 又称系统总体结构设计
- 将系统功能需求分配给软件模块
- 确定每个模块的功能和调用关系
- 形成软件模块结构图（系统结构图）

**详细设计基本任务：**
- 模块内详细算法设计
- 模块内数据结构设计
- 数据库物理设计
- 其他设计（代码、输入/输出格式、用户界面）
- 编写详细设计说明书
- 评审

#### 8.2 系统设计基本原理 ⭐⭐⭐⭐⭐

**四大原理：**
1. **抽象化**
2. **自顶而下，逐步求精**
3. **信息隐蔽**
4. **模块独立**（高内聚，低耦合）

**系统设计原则：**
- 保持模块大小适中
- 尽可能减少调用深度
- 多扇入，少扇出
- 单入口，单出口
- 模块作用域应在模块之内
- 功能应该是可预测的

#### 8.3 内聚性 ⭐⭐⭐⭐⭐

**内聚程度从低到高：**

| 内聚类型 | 定义 | 记忆关键字 |
|----------|------|------------|
| **偶然内聚** | 模块内各处理元素之间没有任何联系 | 无直接关系 |
| **逻辑内聚** | 执行若干逻辑上相似的功能<br>通过参数确定完成哪个功能 | 逻辑相似<br>参数决定 |
| **时间内聚** | 需要同时执行的动作组合在一起 | 同时执行 |
| **过程内聚** | 完成多个任务<br>必须按指定过程执行 | 指定过程顺序 |
| **通信内聚** | 所有处理元素在同一数据结构上操作<br>或使用相同输入输出数据 | 相同数据结构<br>相同输入输出 |
| **顺序内聚** | 各处理元素密切相关于同一功能<br>必须顺序执行<br>前一功能输出是下一功能输入 | 顺序执行<br>输出为输入 |
| **功能内聚** | 所有元素共同作用完成一个功能<br>缺一不可 | 共同作用<br>缺一不可 |

**记忆口诀：** "偶逻时过通顺功" （从低到高）

**最强内聚：** 功能内聚
**最弱内聚：** 偶然内聚

#### 8.4 耦合性 ⭐⭐⭐⭐⭐

**耦合程度从低到高：**

| 耦合类型 | 定义 | 记忆关键字 |
|----------|------|------------|
| **无直接耦合** | 两模块之间没有直接关系<br>分属于不同模块控制与调用 | 无直接关系 |
| **数据耦合** | 有调用关系<br>传递简单数据值<br>相当于值传递 | 传递数据值调用 |
| **标记耦合** | 传递的是数据结构 | 传递数据结构 |
| **控制耦合** | 传递控制变量<br>被调用模块通过控制变量<br>选择执行某一功能 | 控制变量<br>选择执行 |
| **外部耦合** | 通过软件之外的环境联合<br>如I/O将模块耦合到特定设备 | 软件外部环境 |
| **公共耦合** | 通过公共数据环境相互作用 | 公共数据结构 |
| **内容耦合** | 一个模块直接使用另一模块内部数据<br>或通过非正常入口转入另一模块 | 模块内部关联 |

**记忆口诀：** "无数标控外公内" （从低到高）

**最弱耦合：** 无直接耦合、数据耦合
**最强耦合：** 内容耦合

**设计目标：** 高内聚、低耦合

#### 8.5 扇入扇出 ⭐⭐⭐

**扇入：**
- 调用该模块的模块数量
- 扇入大：模块复用程度高

**扇出：**
- 该模块调用的模块数量
- 扇出过大：应进一步分解下级模块
- 扇出过小：应适当增加中间控制模块

---

### 9. 人机界面设计 ⭐⭐⭐

#### 9.1 三大黄金原则

**1. 置于用户控制之下：**
- 用户主导交互
- 提供灵活的交互方式
- 允许中断和撤销
- 隐藏技术内部细节

**2. 减少用户的记忆负担：**
- 减少短期记忆需求
- 建立有意义的默认值
- 定义直观的快捷方式
- 视觉布局基于真实世界的隐喻
- 以渐进的方式揭示信息

**3. 保持界面一致性：**
- 一致的操作序列
- 一致的术语
- 一致的视觉布局
- 一致的反馈

---

### 10. 测试基础知识 ⭐⭐⭐⭐⭐

#### 10.1 测试定义与原则

**定义：**
- 为了发现错误而执行程序的过程
- 成功的测试是发现了至今尚未发现错误的测试

**测试原则：** ⭐⭐⭐⭐
1. 应尽早并不断进行测试
2. 测试工作应避免由原开发人员承担
3. 不仅确定输入数据，还要确定预期输出结果
4. 既包含有效合理测试用例，也包含不合理失效用例
5. 检验程序是否做了该做的事，且是否做了不该做的事
6. 严格按照测试计划进行
7. 妥善保存测试计划和测试用例
8. 测试用例可以重复使用或追加测试

#### 10.2 测试方法 ⭐⭐⭐⭐⭐

**静态测试：**
- 被测程序不在机器上运行
- 采用人工检测和计算机辅助静态分析
- 包括：
  - 对文档的静态测试（检查单）
  - 对代码的静态测试（桌前检查、代码审查、代码走查）
- 能发现30%-70%的逻辑设计和编码错误

**动态测试：**
- 在计算机上实际运行程序
- 采用白盒测试和黑盒测试方法

**黑盒测试（功能性测试）：** ⭐⭐⭐⭐⭐
- 不了解软件代码结构
- 根据功能设计用例
- 测试软件功能

**白盒测试（结构性测试）：** ⭐⭐⭐⭐⭐
- 明确代码流程
- 根据代码逻辑设计用例
- 进行用例覆盖

#### 10.3 测试阶段 ⭐⭐⭐⭐⭐

**1. 单元测试（模块测试）：**
- 测试对象：可独立编译的程序模块、软件构件、OO中的类
- 测试依据：软件详细设计说明书

**2. 集成测试：**
- 目的：检查模块之间及模块和已集成软件之间的接口关系
- 验证已集成软件是否符合设计要求
- 测试依据：软件概要设计文档

**3. 确认测试：** ⭐⭐⭐⭐⭐
- 主要验证软件功能、性能等特性是否与用户需求一致
- 类型：
  - **内部确认测试**：软件开发组织内部按SRS测试
  - **Alpha测试**：用户在开发环境下测试
  - **Beta测试**：用户在实际使用环境下测试，通过后才能交付
  - **验收测试**：针对SRS，交付前以用户为主进行的测试

**4. 系统测试：**
- 测试对象：完整的、集成的计算机系统
- 目的：在真实系统工作环境下验证软件配置项能否正确连接
- 测试依据：用户需求或开发合同
- 主要内容：
  - 功能测试（黑盒测试方法）
  - 健壮性测试
  - 性能测试（响应时间、吞吐量、并发用户数、资源利用率）
  - 用户界面测试
  - 安全性测试
  - 安装与反安装测试

**5. 配置项测试：**
- 测试对象：软件配置项
- 目的：检验软件配置项与SRS的一致性
- 测试依据：SRS

**6. 回归测试：**
- 目的：测试软件变更后
  - 变更部分的正确性
  - 对变更需求的符合性
  - 软件原有正确功能、性能的不损害性

#### 10.4 测试用例设计 ⭐⭐⭐⭐⭐

### 黑盒测试用例设计 ⭐⭐⭐⭐⭐

**1. 等价类划分：** ⭐⭐⭐⭐⭐
- 把所有数据按某种特性归类
- 在每类数据里选取一个即可

**设计原则：**
- 设计新测试用例，尽可能多地覆盖尚未覆盖的有效等价类
- 重复直到所有有效等价类都被覆盖
- 设计新测试用例，仅覆盖一个尚未覆盖的无效等价类
- 重复直到所有无效等价类都被覆盖

**2. 边界值划分：** ⭐⭐⭐⭐⭐
- 将每类的边界值作为测试用例
- 边界值一般为：
  - 范围两端值
  - 范围之外与此范围间隔最小的两个值
- 例：年龄范围0-150，边界值为：-1, 0, 150, 151

**3. 错误推测：**
- 没有固定方法
- 凭经验推测可能产生问题的地方

**4. 因果图：**
- 由结果反推原因的方法
- 具体结果具体分析
- 没有固定方法

### 白盒测试用例设计 ⭐⭐⭐⭐⭐

**覆盖级别从低到高：**

**1. 语句覆盖（SC）：** ⭐⭐⭐⭐
- 逻辑代码中所有语句都要被执行一遍
- 覆盖层级最低
- 执行了所有语句不代表执行了所有条件判断

**2. 判定覆盖（DC）：** ⭐⭐⭐⭐
- 所有判断语句的条件的真假分支都要覆盖一次

**3. 条件覆盖（CC）：** ⭐⭐⭐⭐
- 针对每个判断条件内的每个独立条件
- 都要执行一遍真和假

**4. 条件判定组合覆盖（CDC）：** ⭐⭐⭐⭐
- 同时满足判定覆盖和条件覆盖

**5. 路径覆盖：** ⭐⭐⭐⭐⭐
- 逻辑代码中所有可行路径都覆盖
- 覆盖层级最高

**覆盖强度排序：**
```
语句覆盖 < 判定覆盖 < 条件覆盖 < 条件判定组合覆盖 < 路径覆盖
```

**记忆口诀：** "语判条条路"

---

### 11. 调试 ⭐⭐⭐

#### 11.1 调试与测试的区别
- **测试**：发现错误
- **调试**：找出错误的代码和原因

#### 11.2 调试步骤
1. 确定错误的准确位置
2. 确定问题的原因并设法改正
3. 改正后进行回归测试

#### 11.3 调试方法 ⭐⭐⭐

**蛮力法：**
- 直接查找

**回溯法：**
- 从出错的地方开始，向回找

**原因排除法：** ⭐⭐⭐⭐
- 找出所有可能的原因
- 逐一进行排除
- 具体包括：
  - 演绎法
  - 归纳法
  - 二分法

---

### 12. 软件度量 ⭐⭐⭐⭐

#### 12.1 软件的两种属性

**外部属性：**
- 面向管理者和用户的属性
- 可直接测量
- 一般为性能指标

**内部属性：**
- 软件产品本身的属性
- 如可靠性等
- 只能间接测量

#### 12.2 McCabe度量法（环路复杂度）⭐⭐⭐⭐⭐

**公式：**
```
环路复杂度 = m - n + 2
```

其中：
- m：有向边数（分支边、连线）
- n：节点数（语句框）

**记忆方法：**
- 用最简单的环路特殊值记忆
- 一个分支边就是一条有向边
- 一条语句就是一个顶点

**注意：**
- m和n代表的含义不能混淆
- 针对程序流程图计算

---

### 13. 系统运行与维护 ⭐⭐⭐⭐

#### 13.1 遗留系统 ⭐⭐⭐

**定义：**
- 基本上不能进行修改和演化以满足新业务需求的信息系统

**特点：**
1. 完成许多重要业务管理工作，但不能完全满足要求
2. 性能落后，采用的技术已过时
3. 大型软件系统，融入企业运作，维护困难
4. 没有使用现代方法管理和开发，基本没有文档

#### 13.2 系统转换 ⭐⭐⭐⭐⭐

**定义：**
- 新系统开发完毕，投入运行，取代现有系统的过程

**三种转换计划：**

**1. 直接转换：** ⭐⭐⭐⭐
- 现有系统被新系统直接取代
- 风险很大
- 适用：新系统不复杂，或现有系统已不能使用
- 优点：节省成本

**2. 并行转换：** ⭐⭐⭐⭐⭐
- 新系统和老系统并行工作一段时间
- 新系统试运行后再取代
- 风险极小
- 适用：大型系统
- 缺点：耗费人力和时间，难以控制数据转换

**3. 分段转换：** ⭐⭐⭐⭐
- 分期分批逐步转换
- 直接和并行转换的集合
- 将大型系统分为多个子系统
- 依次试运行每个子系统
- 成熟一个转换一个
- 适用：大型项目
- 缺点：更耗时，需协调接口

#### 13.3 数据转换与迁移

**三种方法：**
1. 系统切换前通过工具迁移
2. 系统切换前采用手工录入
3. 系统切换后通过新系统生成

#### 13.4 系统维护 ⭐⭐⭐⭐⭐

**可维护性定义：**
- 维护人员理解、改正、改动、改进软件的难易程度

**评价指标：**
1. **易分析性**：诊断缺陷或失效原因的能力
2. **易改变性**：使指定修改可以被实现的能力
3. **稳定性**：避免由于修改造成意外结果的能力
4. **易测试性**：使已修改软件能被确认的能力
5. **维护性的依从性**：遵循相关标准或约定的能力

**软件维护类型：** ⭐⭐⭐⭐⭐

**1. 正确性维护：**
- 发现了bug而进行的修改
- 被动维护

**2. 适应性维护：** ⭐⭐⭐⭐⭐
- 由于外部环境发生改变
- 被动进行的对软件的修改和升级
- 如：操作系统升级、硬件更换

**3. 完善性维护：** ⭐⭐⭐⭐⭐
- 基于用户主动对软件提出更多需求
- 修改软件，增加更多功能
- 使功能、性能更高，更加完善
- 主动维护

**4. 预防性维护：**
- 对未来可能发生的bug进行预防性修改

**记忆口诀：** "正适完预"

---

### 14. 净室软件工程 ⭐⭐

#### 14.1 定义
- 应用数学与统计学理论
- 经济方式生产高质量软件
- 力图通过严格工程化过程达到零缺陷或接近零缺陷

#### 14.2 核心思想
- 不是先制作产品再消除缺陷
- 要求在规约和设计中消除错误
- 以"净"的方式制作
- 降低软件开发风险

#### 14.3 理论基础
- 函数理论
- 抽样理论

#### 14.4 应用技术手段 ⭐⭐⭐
1. 统计过程控制下的增量式开发
2. 基于函数的规范与设计
3. 正确性验证（CSE的核心）
4. 统计测试和软件认证

#### 14.5 缺点
1. 太理论化，需要更多数学知识
2. 正确性验证步骤困难且耗时
3. 开发小组不进行传统模块测试不现实
4. 也会带有传统软件工程的弊端

---

### 15. 基于构件的软件工程（CBSE）⭐⭐⭐⭐

#### 15.1 定义
- 基于分布对象技术
- 强调通过可复用构件设计与构造软件系统
- 体现"购买而不是重新构造"的哲学
- 将软件开发重点从编程转移到基于已有构件的组装

#### 15.2 构件特征 ⭐⭐⭐⭐

**1. 可组装性：**
- 所有外部交互通过公开定义的接口进行
- 必须对自身信息的外部访问

**2. 可部署性：**
- 必须是自包含的
- 能作为独立实体运行
- 构件总是二进制形式
- 无须在部署前编译

**3. 文档化：**
- 必须是完全文档化的
- 用户根据文档判断构件是否满足需求

**4. 独立性：**
- 应该是独立的
- 可在无其他特殊构件情况下组装和部署
- 如需其他构件提供服务，应显示声明

**5. 标准化：**
- 必须符合某种标准化的构件模型

#### 15.3 构件模型要素 ⭐⭐⭐⭐

**接口：**
- 构件通过接口定义
- 规定如何定义构件接口
- 包含：操作名、参数、异常等

**使用信息：**
- 给构件特定的、全局唯一的名字或句柄
- 构件元数据：构件相关的数据

**部署：**
- 规格说明如何打包构件
- 使其部署成独立可执行实体
- 包含包中内容信息和二进制构成信息

#### 15.4 构件模型服务

**平台服务：**
- 允许构件在分布式环境下通信和互操作

**支持服务：**
- 很多构件需要的共性服务
- 如：身份认证服务
- 中间件实现共性构件服务

#### 15.5 CBSE过程 ⭐⭐⭐⭐

**六个主要活动：**
1. 系统需求概览
2. 识别候选构件
3. 根据发现的构件修改需求
4. 体系结构设计
5. 构件定制与适配
6. 组装构件创建系统

#### 15.6 CBSE与传统开发过程不同点 ⭐⭐⭐⭐

1. CBSE早期需要完整需求，以便识别可复用构件
2. 早期阶段根据可利用构件细化和修改需求
3. 体系结构设计完成后，进一步搜索构件和设计精化
4. 开发就是将已找到构件集成在一起的组装过程

#### 15.7 构件组装方式 ⭐⭐⭐⭐⭐

**1. 顺序组装：**
- 按顺序调用已存在的构件
- 上一个构件输出作为下一个构件输入

**2. 层次组装：**
- 一个构件直接调用另一个构件提供的服务
- 被调用构件为调用构件提供所需服务
- 二者接口匹配兼容

**3. 叠加组装：**
- 两个或多个构件放在一起创建新构件
- 新构件合并原构件功能
- 对外提供新接口
- 原有构件不互相依赖，不互相调用

#### 15.8 构件组装的三种不兼容问题 ⭐⭐⭐⭐

**解决方法：** 编写适配器

**1. 参数不兼容：**
- 接口每一侧操作有相同名字
- 但参数类型或参数个数不相同

**2. 操作不兼容：**
- 提供接口和请求接口的操作名不同

**3. 操作不完备：**
- 一个构件的提供接口是另一个构件请求接口的子集
- 或者相反

---

## 🔥 重难点分析

### 重点1：CMM/CMMI能力成熟度模型 ⭐⭐⭐⭐⭐
**难度**：★★★★☆
**考试频率**：极高
**掌握要求**：
- 熟记CMM五个等级的名称和特点
- 掌握CMMI各等级的过程域
- 重点记忆2级和3级的过程域
- 理解各等级之间的递进关系

**记忆要点：**
- CMM：初可已已优
- CMMI 2级：7个过程域
- CMMI 3级：13个过程域

### 重点2：软件过程模型 ⭐⭐⭐⭐⭐
**难度**：★★★★☆
**考试频率**：极高
**掌握要求**：
- 掌握各模型的特点和适用场景
- 重点掌握瀑布模型和螺旋模型
- 理解敏捷开发的核心思想
- 掌握RUP的特点和阶段

**关键字记忆：**
- 瀑布：需求明确
- 螺旋：风险驱动、大型复杂
- 原型：需求不明确
- 增量：逐步交付

### 重点3：需求工程 ⭐⭐⭐⭐⭐
**难度**：★★★★★
**考试频率**：极高
**掌握要求**：
- 区分业务需求、用户需求、系统需求
- 掌握需求获取方法及其特点
- 理解数据流图和数据字典
- 掌握需求跟踪矩阵的使用

**易错点：**
- 业务需求：高层次目标
- 用户需求：用户具体目标
- 系统需求：功能需求+非功能需求+设计约束

### 重点4：数据流图（DFD）⭐⭐⭐⭐⭐
**难度**：★★★★☆
**考试频率**：高
**掌握要求**：
- 掌握四个基本元素
- 识别三种常见错误
- 理解数据字典符号含义

**三种错误：**
- 黑洞：有输入无输出
- 奇迹：有输出无输入
- 灰洞：输入不足以产生输出

### 重点5：内聚与耦合 ⭐⭐⭐⭐⭐
**难度**：★★★★☆
**考试频率**：极高
**掌握要求**：
- 熟记内聚的7种类型及排序
- 熟记耦合的7种类型及排序
- 能快速判断给定模块的内聚耦合类型
- 理解高内聚低耦合的设计目标

**记忆口诀：**
- 内聚：偶逻时过通顺功（从低到高）
- 耦合：无数标控外公内（从低到高）

### 重点6：测试方法与测试阶段 ⭐⭐⭐⭐⭐
**难度**：★★★★☆
**考试频率**：极高
**掌握要求**：
- 区分黑盒测试和白盒测试
- 掌握测试阶段及其测试依据
- 理解确认测试的四种类型
- 掌握白盒测试的覆盖级别

**测试阶段记忆：**
- 单元测试：详细设计说明书
- 集成测试：概要设计文档
- 确认测试：SRS
- 系统测试：用户需求或开发合同

### 重点7：白盒测试覆盖 ⭐⭐⭐⭐⭐
**难度**：★★★★★
**考试频率**：高
**掌握要求**：
- 理解五种覆盖级别
- 能根据代码判断覆盖类型
- 掌握覆盖强度排序

**覆盖强度：**
语句 < 判定 < 条件 < 条件判定组合 < 路径

### 重点8：McCabe度量法 ⭐⭐⭐⭐⭐
**难度**：★★★☆☆
**考试频率**：中
**掌握要求**：
- 熟记公式：m - n + 2
- 能根据流程图计算环路复杂度
- 注意m是边数，n是节点数

### 重点9：系统转换方式 ⭐⭐⭐⭐
**难度**：★★★☆☆
**考试频率**：中
**掌握要求**：
- 区分三种转换方式
- 理解各自的优缺点和适用场景

### 重点10：软件维护类型 ⭐⭐⭐⭐⭐
**难度**：★★★☆☆
**考试频率**：高
**掌握要求**：
- 区分四种维护类型
- 重点掌握适应性维护和完善性维护
- 理解主动维护和被动维护

**记忆口诀：** "正适完预"

---

## 📝 学习建议

### 学习顺序
1. 软件工程概述（基础）
2. CMM/CMMI（核心重点）
3. 软件过程模型（核心重点）
4. 需求工程（核心重点）
5. 系统设计（核心重点）
6. 测试基础（核心重点）
7. 系统维护（重点）
8. 其他专题（了解）

### 复习策略
1. **必须掌握**：
   - CMM/CMMI等级和过程域
   - 各种软件过程模型特点
   - 需求分类和需求获取方法
   - 数据流图和数据字典
   - 内聚与耦合
   - 测试方法和测试阶段
   - 白盒测试覆盖
   - 软件维护类型

2. **重点理解**：
   - RUP的特点和阶段
   - 敏捷开发思想
   - 需求跟踪矩阵
   - 系统转换方式
   - CBSE构件组装

3. **一般了解**：
   - 逆向工程
   - 净室软件工程
   - 人机界面设计

### 易错点提醒
1. CMM和CMMI的等级名称不要混淆
2. 瀑布模型关键字：需求明确
3. 螺旋模型关键字：风险驱动
4. 业务需求、用户需求、系统需求要区分清楚
5. 数据流图三种错误：黑洞、奇迹、灰洞
6. 内聚从低到高：偶逻时过通顺功
7. 耦合从低到高：无数标控外公内
8. 白盒测试覆盖强度：语句<判定<条件<条件判定组合<路径
9. 测试阶段的测试依据不要混淆
10. 适应性维护是外部环境变化，完善性维护是用户主动提需求

---

## 💡 记忆口诀

**CMM等级：**
"初可已已优" 或 "1混2重3定4管5优"

**软件过程模型：**
"瀑布需求明，螺旋风险大，原型不明确，增量逐步交"

**需求三分类：**
"业务高层次，用户具体标，系统分三类"

**数据流图错误：**
"黑洞无输出，奇迹无输入，灰洞不够用"

**数据字典符号：**
"等号定义，加号组成，方括或，花括重复"

**内聚类型：**
"偶逻时过通顺功"（从低到高）

**耦合类型：**
"无数标控外公内"（从低到高）

**测试方法：**
"静态不运行，动态分黑白"

**测试阶段：**
"单集确系配回"

**白盒覆盖：**
"语判条条路"（从低到高）

**软件维护：**
"正适完预"

**系统转换：**
"直接快风险，并行慢安全，分段最耗时"

**RUP四阶段：**
"初细构移"

**RUP特点：**
"用例驱动，架构中心，迭代增量"

---

## ⏰ 预计学习时间分配

- 软件工程概述：1小时
- CMM/CMMI：2小时（含记忆）
- 软件过程模型：3小时（含练习）
- 逆向工程：0.5小时
- 需求工程：3小时（含练习）
- 系统设计：2小时（含练习）
- 人机界面设计：0.5小时
- 测试基础：3小时（含大量练习）
- 调试与度量：0.5小时
- 系统维护：1小时
- 净室与CBSE：1小时
- 总复习与习题：2小时

**总计：约18-20小时**

---

## 🎯 考试题型分布

| 题型 | 考点 | 分值 | 难度 |
|------|------|------|------|
| 选择题 | CMM/CMMI等级 | 2-3分 | ★★★★ |
| 选择题 | 软件过程模型 | 2-3分 | ★★★★ |
| 选择题 | 需求分类 | 1-2分 | ★★★ |
| 综合题 | 数据流图 | 2-3分 | ★★★★ |
| 选择题 | 内聚与耦合 | 2-3分 | ★★★★ |
| 综合题 | 测试方法 | 2-3分 | ★★★★ |
| 综合题 | 白盒测试覆盖 | 2-3分 | ★★★★★ |
| 计算题 | McCabe度量 | 1-2分 | ★★★ |
| 选择题 | 软件维护 | 1-2分 | ★★★ |
| 选择题 | 系统转换 | 1分 | ★★☆ |

**注意：** 本章是考试重点章节，分值占比很高（12-15分），务必重点掌握！


## 10.X 必背知识点速查 ⭐⭐⭐⭐⭐

### CMM/CMMI五个等级（必背）⭐⭐⭐⭐⭐
```
┌────┬──────┬──────────┬──────────────┐
│等级│名称  │ CMM特点  │ CMMI特点     │
├────┼──────┼──────────┼──────────────┤
│ 1  │初始级│ 混乱无章 │ 不可预测     │
│    │      │ 个人英雄 │ 缺乏控制     │
├────┼──────┼──────────┼──────────────┤
│ 2  │可重复│ 基本管理 │ 过程为项目   │
│    │已管理│ 可重复   │ 服务(7个域)  │
├────┼──────┼──────────┼──────────────┤
│ 3  │已定义│ 文档化   │ 过程为组织   │
│    │      │ 标准化   │ 服务(13个域) │
├────┼──────┼──────────┼──────────────┤
│ 4  │已管理│ 定量控制 │ 过程已度量   │
│    │定量  │ 度量标准 │ 和控制(2个域)│
├────┼──────┼──────────┼──────────────┤
│ 5  │优化级│ 持续改进 │ 集中改进     │
│    │      │ 定量分析 │ 优化(2个域)  │
└────┴──────┴──────────┴──────────────┘

记忆口诀：
初可已已优（1-5级）
混重定管优（特点）
1混2重3定4管5优
```

### CMMI 2级过程域（必背）⭐⭐⭐⭐⭐
```
已管理级（2级）7个过程域：
1. 需求管理（REQM）
2. 项目计划（PP）
3. 项目监督与控制（PMC）
4. 供应商合同管理（SAM）
5. 度量和分析（MA）
6. 过程和产品质量保证（PPQA）
7. 配置管理（CM）

记忆口诀：
需计监供度质配
（需求、计划、监督、供应商、度量、质量、配置）
```

### 软件过程模型对比（必背）⭐⭐⭐⭐⭐
```
┌──────┬──────────┬──────────┬──────────┐
│模型  │ 瀑布模型 │ 螺旋模型 │ 原型模型 │
├──────┼──────────┼──────────┼──────────┤
│特点  │ 顺序执行 │ 风险驱动 │ 快速原型 │
│      │ 文档驱动 │ 迭代演化 │ 用户参与 │
├──────┼──────────┼──────────┼──────────┤
│适用  │ 需求明确 │ 大型复杂 │ 需求不清 │
│      │ 功能清晰 │ 高风险   │ 用户交互 │
├──────┼──────────┼──────────┼──────────┤
│优点  │ 简单易懂 │ 风险可控 │ 需求准确 │
│      │ 易于管理 │ 灵活性高 │ 用户满意 │
├──────┼──────────┼──────────┼──────────┤
│缺点  │ 不灵活   │ 复杂难控 │ 管理困难 │
│      │ 风险大   │ 成本高   │ 文档不全 │
└──────┴──────────┴──────────┴──────────┘

关键字识别：
- "需求明确" → 瀑布
- "风险"、"大型" → 螺旋
- "需求不清"、"原型" → 原型化
- "快速迭代"、"增量" → 敏捷
```

### 测试阶段与方法（必背）⭐⭐⭐⭐⭐
```
测试阶段（从小到大）：
1. 单元测试（模块测试）
   - 测试对象：单个模块
   - 测试者：开发人员
   - 测试方法：白盒测试为主

2. 集成测试（组装测试）
   - 测试对象：模块接口
   - 测试者：开发人员
   - 测试方法：黑盒+白盒

3. 系统测试（确认测试）
   - 测试对象：整个系统
   - 测试者：独立测试组
   - 测试方法：黑盒测试为主

4. 验收测试（交付测试）
   - 测试对象：完整系统
   - 测试者：用户
   - 测试方法：黑盒测试

记忆口诀：
单集系验（单元、集成、系统、验收）
从小到大，从内到外
```

### 白盒测试方法（必背）⭐⭐⭐⭐⭐
```
1. 语句覆盖（最弱）
   - 每条语句至少执行一次

2. 判定覆盖（分支覆盖）
   - 每个判定的真假分支至少执行一次

3. 条件覆盖
   - 每个条件的真假至少出现一次

4. 判定/条件覆盖
   - 同时满足判定覆盖和条件覆盖

5. 条件组合覆盖
   - 所有条件的所有组合至少出现一次

6. 路径覆盖（最强）
   - 所有可能的执行路径至少执行一次

覆盖强度（从弱到强）：
语句 < 判定 < 条件 < 判定/条件 < 条件组合 < 路径

记忆口诀：
语判条判条路（语句、判定、条件、判定条件、条件组合、路径）
```

### 黑盒测试方法（必背）⭐⭐⭐⭐⭐
```
1. 等价类划分
   - 将输入域划分为若干等价类
   - 每类选一个代表测试

2. 边界值分析
   - 测试边界值和边界附近的值
   - 最常用、最有效

3. 错误推测法
   - 根据经验推测可能的错误

4. 因果图法
   - 分析输入条件的组合
   - 产生测试用例

记忆口诀：
等边错因（等价类、边界值、错误推测、因果图）
边界值最常用
```

### 软件维护类型（必背）⭐⭐⭐⭐⭐
```
1. 纠正性维护（20%）
   - 修复错误和缺陷
   - 诊断和改正错误

2. 适应性维护（25%）
   - 适应环境变化
   - 平台、OS、硬件变化

3. 完善性维护（50%）← 最多
   - 功能增强
   - 性能改进
   - 用户体验优化

4. 预防性维护（5%）← 最少
   - 预防未来问题
   - 代码重构
   - 文档更新

占比记忆：
完善一半（50%）
适应四分一（25%）
纠正五分一（20%）
预防最少（5%）
```

## 10.Y 快速记忆口诀大全 ⭐⭐⭐⭐⭐

### CMM/CMMI等级
```
初可已已优，五个等级要记牢
1级混乱靠英雄，2级管理可重复
3级定义标准化，4级度量定量控
5级优化持续改，等级越高越成熟
```

### CMMI 2级过程域
```
需计监供度质配，七个过程域要背
需求管理是基础，项目计划要做好
监督控制不能少，供应商管理要抓牢
度量分析看数据，质量保证是关键
配置管理保版本，二级管理为项目
```

### 软件过程模型
```
瀑布模型顺序走，需求明确最适合
螺旋模型风险驱，大型复杂高风险
原型模型快速建，需求不清用户参
敏捷开发快迭代，拥抱变化响应快
```

### 测试阶段
```
单元测试测模块，白盒方法开发做
集成测试测接口，黑白结合组装测
系统测试测整体，黑盒为主独立组
验收测试用户做，交付之前最后关
```

### 白盒测试覆盖
```
语句覆盖最简单，每条语句走一遍
判定覆盖看分支，真假分支都要走
条件覆盖看条件，真假取值都要有
路径覆盖最复杂，所有路径都要走
覆盖强度从弱强：语判条判条路
```

### 黑盒测试方法
```
等价类划分分类测，代表测试效率高
边界值分析最常用，边界附近易出错
错误推测靠经验，可能错误提前防
因果图法看组合，输入条件组合测
```

### 软件维护类型
```
纠正维护修bug，占比五分一
适应维护改环境，占比四分一
完善维护增功能，占比整一半
预防维护防未来，占比最最少
```

## 10.Z 典型例题精讲 ⭐⭐⭐⭐⭐

### 例题1：CMM等级判断 ⭐⭐⭐⭐⭐
某软件企业建立了基本的项目管理过程，能够重复以前成功的经验，该企业处于CMM的哪个等级？
A. 初始级  B. 可重复级  C. 已定义级  D. 已管理级

**解析**：
```
CMM五个等级特点：
1级（初始级）：混乱无章，依赖个人英雄
2级（可重复级）：建立基本项目管理，可重复成功经验 ✓
3级（已定义级）：过程文档化、标准化
4级（已管理级）：定量控制、度量标准
5级（优化级）：持续改进、定量分析

题目关键词：
- "基本的项目管理" → 2级特征
- "重复以前成功的经验" → 2级名称"可重复级"
```
**答案**：B

### 例题2：CMMI 2级过程域 ⭐⭐⭐⭐⭐
以下哪个不是CMMI 2级（已管理级）的过程域？
A. 需求管理  B. 项目计划  C. 需求开发  D. 配置管理

**解析**：
```
CMMI 2级（已管理级）7个过程域：
1. 需求管理（REQM）✓
2. 项目计划（PP）✓
3. 项目监督与控制（PMC）
4. 供应商合同管理（SAM）
5. 度量和分析（MA）
6. 过程和产品质量保证（PPQA）
7. 配置管理（CM）✓

需求开发（RD）是3级（已定义级）的过程域 ✗

区别：
- 需求管理（2级）：管理已有需求
- 需求开发（3级）：开发新需求
```
**答案**：C

### 例题3：软件过程模型选择 ⭐⭐⭐⭐⭐
某项目需求不明确，用户难以清晰描述需求，最适合采用哪种开发模型？
A. 瀑布模型  B. 螺旋模型  C. 原型模型  D. V模型

**解析**：
```
模型选择依据：

瀑布模型：
- 适用：需求明确、功能清晰 ✗
- 不适用：需求不明确

螺旋模型：
- 适用：大型复杂、高风险
- 不是专门针对需求不明确

原型模型：
- 适用：需求不清、用户难以描述 ✓
- 特点：快速原型、用户参与、反复修改
- 正是为了解决需求不明确问题

V模型：
- 瀑布模型的变体
- 强调测试，不解决需求问题
```
**答案**：C

### 例题4：测试阶段判断 ⭐⭐⭐⭐⭐
由独立测试组对整个系统进行的测试是？
A. 单元测试  B. 集成测试  C. 系统测试  D. 验收测试

**解析**：
```
测试阶段对比：

单元测试：
- 测试对象：单个模块
- 测试者：开发人员 ✗

集成测试：
- 测试对象：模块接口
- 测试者：开发人员 ✗

系统测试：
- 测试对象：整个系统 ✓
- 测试者：独立测试组 ✓
- 测试方法：黑盒测试为主

验收测试：
- 测试对象：完整系统
- 测试者：用户 ✗

题目关键词：
- "独立测试组" → 系统测试
- "整个系统" → 系统测试
```
**答案**：C

### 例题5：白盒测试覆盖强度 ⭐⭐⭐⭐⭐
以下白盒测试方法中，覆盖强度最强的是？
A. 语句覆盖  B. 判定覆盖  C. 条件覆盖  D. 路径覆盖

**解析**：
```
白盒测试覆盖强度（从弱到强）：
语句覆盖 < 判定覆盖 < 条件覆盖 < 
判定/条件覆盖 < 条件组合覆盖 < 路径覆盖

路径覆盖：
- 要求所有可能的执行路径至少执行一次
- 覆盖强度最强
- 但测试用例数量可能非常多
- 实际中很难完全实现

记忆：路径覆盖=所有路径=最强
```
**答案**：D

### 例题6：黑盒测试方法 ⭐⭐⭐⭐⭐
黑盒测试中，最常用且最有效的方法是？
A. 等价类划分  B. 边界值分析  C. 错误推测  D. 因果图

**解析**：
```
黑盒测试方法对比：

等价类划分：
- 将输入域划分为等价类
- 每类选代表测试
- 常用但不是最常用

边界值分析：
- 测试边界值和边界附近的值
- 最常用、最有效 ✓
- 原因：边界处最容易出错

错误推测：
- 根据经验推测错误
- 辅助方法

因果图：
- 分析输入条件组合
- 较复杂

记忆：边界值=最常用=最有效
```
**答案**：B

### 例题7：软件维护类型 ⭐⭐⭐⭐⭐
软件维护中，占比最大的是？
A. 纠正性维护  B. 适应性维护  C. 完善性维护  D. 预防性维护

**解析**：
```
软件维护类型及占比：
1. 纠正性维护：20%（修复错误）
2. 适应性维护：25%（适应环境）
3. 完善性维护：50%（功能增强）← 最大
4. 预防性维护：5%（预防问题）← 最小

完善性维护占比最大的原因：
- 用户需求不断变化
- 功能不断增强
- 性能不断优化
- 用户体验不断改进

记忆：完善性维护=50%=一半=最大
```
**答案**：C

### 例题8：螺旋模型特点 ⭐⭐⭐⭐⭐
螺旋模型最突出的特点是？
A. 文档驱动  B. 风险驱动  C. 用户驱动  D. 测试驱动

**解析**：
```
螺旋模型特点：
1. 演化软件过程模型
2. 结合原型迭代和瀑布系统化
3. 软件开发是一系列增量发布
4. 强调风险分析 ← 最突出特点

螺旋模型四个象限：
1. 制订计划
2. 风险分析 ← 核心
3. 实施工程
4. 客户评估

适用场景：
- 庞大而复杂的系统
- 高风险系统
- 大型软件开发

记忆：螺旋模型=风险驱动
```
**答案**：B

## 10.AA 易错点提醒 ⭐⭐⭐⭐⭐

### 易错点1：CMM vs CMMI
```
❌ 错误：CMM和CMMI完全相同
✅ 正确：
CMM：
- 5个等级：初始、可重复、已定义、已管理、优化
- 只针对软件过程

CMMI：
- 5个等级：初始、已管理、已定义、定量管理、优化
- 集成多个模型（软件、系统、供应商等）
- 2级叫"已管理"不是"可重复"

记忆：CMMI是CMM的升级版
```

### 易错点2：CMMI 2级 vs 3级过程域
```
❌ 错误：需求开发是2级过程域
✅ 正确：
2级（已管理级）：
- 需求管理（管理已有需求）
- 7个过程域

3级（已定义级）：
- 需求开发（开发新需求）
- 13个过程域

区别：
- 需求管理：管理、跟踪需求变更
- 需求开发：获取、分析、定义需求
```

### 易错点3：瀑布模型适用场景
```
❌ 错误：瀑布模型适用于需求不明确的项目
✅ 正确：
瀑布模型适用：
- 需求明确、清晰
- 功能有较清晰定义
- 对交付时间有严格要求

不适用：
- 需求不明确 → 用原型模型
- 高风险 → 用螺旋模型
- 需要快速迭代 → 用敏捷模型
```

### 易错点4：测试阶段的测试者
```
❌ 错误：系统测试由开发人员进行
✅ 正确：
单元测试：开发人员
集成测试：开发人员
系统测试：独立测试组 ← 注意
验收测试：用户

记忆：系统测试=独立测试组
```

### 易错点5：白盒测试覆盖强度
```
❌ 错误：语句覆盖强度最强
✅ 正确：
覆盖强度从弱到强：
语句 < 判定 < 条件 < 判定/条件 < 条件组合 < 路径

路径覆盖强度最强，但实现最困难

记忆：路径覆盖=最强
```

### 易错点6：黑盒测试最常用方法
```
❌ 错误：等价类划分最常用
✅ 正确：
边界值分析最常用、最有效

原因：
- 边界处最容易出错
- 简单易用
- 效果好

记忆：边界值=最常用
```

### 易错点7：软件维护类型占比
```
❌ 错误：纠正性维护占比最大
✅ 正确：
完善性维护占比最大（50%）

占比排序：
完善性（50%）> 适应性（25%）> 纠正性（20%）> 预防性（5%）

记忆：完善性=一半=最大
```

## 10.BB 真题精选 ⭐⭐⭐⭐⭐

### 真题1（2022年）
某企业建立了基本的项目管理过程，能够重复以前成功的经验，该企业处于CMM的（）。
A. 初始级  B. 可重复级  C. 已定义级  D. 已管理级

**答案**：B
**解析**：可重复级的特点是建立基本项目管理，可重复成功经验。

### 真题2（2021年）
以下不是CMMI 2级过程域的是（）。
A. 需求管理  B. 项目计划  C. 需求开发  D. 配置管理

**答案**：C
**解析**：需求开发是3级过程域，需求管理是2级过程域。

### 真题3（2020年）
某项目需求不明确，最适合采用（）开发模型。
A. 瀑布模型  B. 螺旋模型  C. 原型模型  D. V模型

**答案**：C
**解析**：原型模型适用于需求不明确的项目。

### 真题4（2019年）
由独立测试组对整个系统进行的测试是（）。
A. 单元测试  B. 集成测试  C. 系统测试  D. 验收测试

**答案**：C
**解析**：系统测试由独立测试组对整个系统进行测试。

### 真题5（2018年）
白盒测试中，覆盖强度最强的是（）。
A. 语句覆盖  B. 判定覆盖  C. 条件覆盖  D. 路径覆盖

**答案**：D
**解析**：路径覆盖要求所有可能的执行路径至少执行一次，覆盖强度最强。

### 真题6（2017年）
软件维护中，占比最大的是（）。
A. 纠正性维护  B. 适应性维护  C. 完善性维护  D. 预防性维护

**答案**：C
**解析**：完善性维护约占50%，是占比最大的维护类型。

## 10.CC 考试答题技巧 ⭐⭐⭐⭐⭐

### 技巧1：CMM/CMMI等级判断
```
关键词识别：
- "混乱"、"个人英雄" → 1级
- "基本管理"、"可重复" → 2级
- "文档化"、"标准化" → 3级
- "定量"、"度量" → 4级
- "持续改进"、"优化" → 5级
```

### 技巧2：CMMI过程域判断
```
2级（7个）：需计监供度质配
- 关键词：管理、计划、监督、配置

3级（13个）：需求开发、技术解决方案等
- 关键词：开发、定义、培训、风险

记住：需求管理（2级）vs 需求开发（3级）
```

### 技巧3：软件过程模型选择
```
看关键词：
- "需求明确" → 瀑布
- "风险"、"大型" → 螺旋
- "需求不清"、"原型" → 原型化
- "快速迭代" → 敏捷
```

### 技巧4：测试阶段判断
```
看测试对象和测试者：
- 单个模块 + 开发人员 → 单元测试
- 模块接口 + 开发人员 → 集成测试
- 整个系统 + 独立测试组 → 系统测试
- 完整系统 + 用户 → 验收测试
```

### 技巧5：白盒测试覆盖
```
记住顺序：语判条判条路
记住结论：路径覆盖最强
```

### 技巧6：黑盒测试方法
```
记住结论：边界值分析最常用、最有效
原因：边界处最容易出错
```

### 技巧7：软件维护类型
```
记住占比：50% 25% 20% 5%
记住顺序：完善 > 适应 > 纠正 > 预防
记住结论：完善性维护占比最大
```

---

**本章学习建议**：
1. 重点记忆CMM/CMMI五个等级的特点
2. 掌握CMMI 2级7个过程域（必考）
3. 理解各种软件过程模型的适用场景
4. 记住测试阶段的顺序和特点
5. 掌握白盒测试覆盖强度排序
6. 记住软件维护类型的占比
7. 多做真题，熟悉题型和陷阱
8. 使用口诀和对比表辅助记忆
