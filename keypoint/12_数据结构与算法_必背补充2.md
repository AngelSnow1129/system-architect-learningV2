# 第12章：数据结构与算法 - 必背补充内容（续）

### 例题3：二叉树遍历 ⭐⭐⭐⭐⭐
某二叉树的前序遍历序列为ABDEC，中序遍历序列为DBEAC，则后序遍历序列为？
A. DEBCA  B. DECBA  C. DEABC  D. EDCBA

**解析**：
```
已知：
前序：ABDEC（根左右）
中序：DBEAC（左根右）

步骤1：前序第一个A是根
步骤2：在中序中找A，左边DBE是左子树，右边C是右子树
步骤3：前序中A后面的BDE是左子树，C是右子树
步骤4：递归处理左子树BDE
  - 前序：BDE，中序：DBE
  - B是根，D是左子树，E是右子树
步骤5：递归处理右子树C
  - C是叶子节点

树的结构：
      A
     / \
    B   C
   / \
  D   E

后序遍历（左右根）：D E B C A

答案：DEBCA
```
**答案**：A

### 例题4：二叉树还原 ⭐⭐⭐⭐⭐
以下哪种遍历序列组合不能唯一确定一棵二叉树？
A. 前序+中序  B. 后序+中序  C. 前序+后序  D. 层序+中序

**解析**：
```
可以唯一确定二叉树的组合：
1. 前序 + 中序 ✓
2. 后序 + 中序 ✓
3. 层序 + 中序 ✓

不能唯一确定的组合：
1. 前序 + 后序 ✗（无法确定左右子树）
2. 前序 + 层序 ✗
3. 后序 + 层序 ✗

原因：
- 中序遍历可以区分左右子树
- 前序/后序/层序可以确定根节点
- 没有中序，无法区分左右子树

例如：前序AB，后序BA
可能是：
  A        A
   \      /
    B    B
两种不同的树

记忆：中序必须有，前后层任选一
```
**答案**：C

### 例题5：图的遍历 ⭐⭐⭐⭐⭐
深度优先搜索（DFS）使用的数据结构是？
A. 队列  B. 栈  C. 堆  D. 树

**解析**：
```
图的遍历算法：

深度优先搜索（DFS）：
- 数据结构：栈（或递归）✓
- 策略：尽可能深地搜索
- 特点：沿着一条路走到底，再回溯

广度优先搜索（BFS）：
- 数据结构：队列
- 策略：逐层搜索
- 特点：先访问邻居，再访问邻居的邻居

记忆：
- DFS用栈（Stack）：深度=栈
- BFS用队列（Queue）：广度=队列
```
**答案**：B

### 例题6：最小生成树 ⭐⭐⭐⭐⭐
Prim算法和Kruskal算法的主要区别是？
A. Prim从顶点出发，Kruskal从边出发
B. Prim适用稀疏图，Kruskal适用稠密图
C. Prim时间复杂度低，Kruskal时间复杂度高
D. Prim是贪心算法，Kruskal是动态规划

**解析**：
```
Prim算法：
- 策略：从顶点出发 ✓
- 步骤：选择与已选顶点相连的最小边
- 适用：稠密图
- 复杂度：O(n²)

Kruskal算法：
- 策略：从边出发 ✓
- 步骤：按边权值排序，依次选择不成环的最小边
- 适用：稀疏图
- 复杂度：O(e log e)

选项分析：
A. 正确：Prim从顶点出发，Kruskal从边出发 ✓
B. 错误：应该是Prim适用稠密图，Kruskal适用稀疏图
C. 错误：复杂度取决于图的类型
D. 错误：两者都是贪心算法

记忆：
- Prim=Point（点）=从顶点出发
- Kruskal=从边（Edge）出发
```
**答案**：A

### 例题7：最短路径 ⭐⭐⭐⭐⭐
Dijkstra算法不能处理的情况是？
A. 有向图  B. 无向图  C. 负权边  D. 带权图

**解析**：
```
Dijkstra算法：
- 用途：单源最短路径
- 策略：贪心算法
- 限制：不能处理负权边 ✓

原因：
Dijkstra算法基于贪心策略，每次选择当前距离最小的顶点。
如果存在负权边，已经确定的最短路径可能被后续的负权边更新，
导致算法失效。

选项分析：
A. 有向图：可以处理
B. 无向图：可以处理
C. 负权边：不能处理 ✓
D. 带权图：可以处理（只要权值非负）

如果有负权边，应该使用：
- Bellman-Ford算法（单源，可处理负权）
- Floyd算法（所有对，可处理负权）

记忆：Dijkstra不能有负权
```
**答案**：C

### 例题8：查找算法 ⭐⭐⭐⭐⭐
二分查找的前提条件是？
A. 数据量大  B. 数据有序  C. 数据连续  D. 数据唯一

**解析**：
```
二分查找（Binary Search）：
- 时间复杂度：O(log n)
- 前提条件：数据必须有序 ✓
- 策略：每次折半查找

算法步骤：
1. 取中间元素
2. 如果等于目标，返回
3. 如果小于目标，在右半部分查找
4. 如果大于目标，在左半部分查找
5. 重复直到找到或范围为空

选项分析：
A. 数据量大：不是必须的，小数据也可以用
B. 数据有序：必须的前提条件 ✓
C. 数据连续：不需要，只要有序即可
D. 数据唯一：不需要，可以有重复元素

记忆：二分查找=有序数据=折半查找
```
**答案**：B

## 12.AA 易错点提醒 ⭐⭐⭐⭐⭐

### 易错点1：时间复杂度比较
```
❌ 错误：O(n) < O(log n)
✅ 正确：O(log n) < O(n)

记忆：对数 < 线性 < 平方
O(log n) < O(n) < O(n²)
```

### 易错点2：排序稳定性
```
❌ 错误：快速排序是稳定的
✅ 正确：快速排序是不稳定的

稳定：冒泡、插入、归并
不稳定：选择、快速、堆

记忆口诀：冒插归稳定，选快堆不稳
```

### 易错点3：二叉树还原
```
❌ 错误：前序+后序可以唯一确定二叉树
✅ 正确：前序+后序不能唯一确定

可以确定：
- 前序+中序 ✓
- 后序+中序 ✓
- 层序+中序 ✓

不能确定：
- 前序+后序 ✗

记忆：中序必须有
```

### 易错点4：DFS和BFS的数据结构
```
❌ 错误：DFS用队列，BFS用栈
✅ 正确：DFS用栈，BFS用队列

记忆：
- DFS=深度=栈（Stack）
- BFS=广度=队列（Queue）
```

### 易错点5：Prim和Kruskal适用场景
```
❌ 错误：Prim适用稀疏图
✅ 正确：Prim适用稠密图，Kruskal适用稀疏图

记忆：
- Prim=Point=顶点多=稠密图
- Kruskal=Edge=边少=稀疏图
```

### 易错点6：Dijkstra算法限制
```
❌ 错误：Dijkstra可以处理负权边
✅ 正确：Dijkstra不能处理负权边

原因：贪心策略，已确定的路径可能被负权边更新

如果有负权边：
- 单源：Bellman-Ford
- 所有对：Floyd
```

### 易错点7：二分查找前提
```
❌ 错误：二分查找只要数据量大就可以用
✅ 正确：二分查找必须数据有序

前提条件：
1. 数据有序（必须）
2. 支持随机访问（通常是数组）

记忆：二分查找=有序数据
```

## 12.BB 真题精选 ⭐⭐⭐⭐⭐

### 真题1（2022年）
以下时间复杂度从小到大排序正确的是（）。
A. O(n) < O(log n) < O(n²)
B. O(log n) < O(n) < O(n²)
C. O(1) < O(n) < O(log n)
D. O(n²) < O(n) < O(log n)

**答案**：B
**解析**：时间复杂度从小到大：O(log n) < O(n) < O(n²)。

### 真题2（2021年）
以下排序算法中，不稳定的是（）。
A. 冒泡排序  B. 插入排序  C. 快速排序  D. 归并排序

**答案**：C
**解析**：快速排序是不稳定的，冒泡、插入、归并是稳定的。

### 真题3（2020年）
某二叉树前序遍历为ABDEC，中序遍历为DBEAC，后序遍历为（）。
A. DEBCA  B. DECBA  C. DEABC  D. EDCBA

**答案**：A
**解析**：根据前序和中序可以还原二叉树，后序遍历为DEBCA。

### 真题4（2019年）
以下哪种遍历序列组合不能唯一确定一棵二叉树？
A. 前序+中序  B. 后序+中序  C. 前序+后序  D. 层序+中序

**答案**：C
**解析**：前序+后序不能唯一确定二叉树，必须有中序。

### 真题5（2018年）
深度优先搜索（DFS）使用的数据结构是（）。
A. 队列  B. 栈  C. 堆  D. 树

**答案**：B
**解析**：DFS使用栈（或递归），BFS使用队列。

### 真题6（2017年）
Dijkstra算法不能处理的情况是（）。
A. 有向图  B. 无向图  C. 负权边  D. 带权图

**答案**：C
**解析**：Dijkstra算法不能处理负权边。

## 12.CC 考试答题技巧 ⭐⭐⭐⭐⭐

### 技巧1：时间复杂度比较
```
记住顺序：
O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!)

口诀：常对线线平方指阶

快速判断：
- 常数操作 → O(1)
- 折半查找 → O(log n)
- 单层循环 → O(n)
- 快排归并 → O(n log n)
- 双层循环 → O(n²)
```

### 技巧2：排序算法选择
```
看稳定性要求：
- 需要稳定 → 冒泡、插入、归并
- 不需要稳定 → 快速、堆

看时间要求：
- 要求快 → 快速、归并、堆（O(n log n)）
- 可以慢 → 冒泡、选择、插入（O(n²)）

看空间要求：
- 空间少 → 冒泡、选择、插入、堆（O(1)）
- 可以多 → 归并（O(n)）
```

### 技巧3：二叉树遍历
```
记住规律：
- 前序：根在前（根左右）
- 中序：根在中（左根右）
- 后序：根在后（左右根）

还原二叉树：
1. 必须有中序
2. 前序/后序/层序任选一个
3. 前序第一个/后序最后一个是根
4. 在中序中找根，分左右子树
```

### 技巧4：图的遍历
```
看数据结构：
- 栈（或递归）→ DFS
- 队列 → BFS

看应用场景：
- 拓扑排序 → DFS
- 最短路径 → BFS
```

### 技巧5：最小生成树
```
看出发点：
- 从顶点出发 → Prim
- 从边出发 → Kruskal

看图的类型：
- 稠密图（边多）→ Prim
- 稀疏图（边少）→ Kruskal
```

### 技巧6：最短路径
```
看问题类型：
- 单源最短路径 → Dijkstra
- 所有对最短路径 → Floyd

看权值：
- 非负权 → Dijkstra
- 有负权 → Floyd或Bellman-Ford
```

### 技巧7：查找算法
```
看数据特征：
- 无序 → 顺序查找
- 有序 → 二分查找
- 哈希表 → 哈希查找

看时间要求：
- 最快 → 哈希查找O(1)
- 较快 → 二分查找O(log n)
- 可以慢 → 顺序查找O(n)
```

---

**本章学习建议**：
1. 重点记忆时间复杂度的比较顺序
2. 掌握排序算法的稳定性（必考）
3. 熟练掌握二叉树遍历和还原方法
4. 理解DFS和BFS的区别和应用
5. 掌握最小生成树和最短路径算法
6. 多做二叉树还原的练习题
7. 使用口诀和对比表辅助记忆
8. 真题中的算法题要画图辅助理解
