# 第12章：数据结构与算法 - 必背补充内容

## 12.X 必背知识点速查 ⭐⭐⭐⭐⭐

### 时间复杂度排序（必背）⭐⭐⭐⭐⭐
```
从快到慢：
O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(n³) < O(2ⁿ) < O(n!)

常见算法复杂度：
┌──────────┬──────────┬──────────────┐
│复杂度    │ 名称     │ 典型算法     │
├──────────┼──────────┼──────────────┤
│ O(1)     │ 常数阶   │ 数组访问     │
│          │          │ 哈希表查找   │
├──────────┼──────────┼──────────────┤
│ O(log n) │ 对数阶   │ 二分查找     │
│          │          │ 平衡树操作   │
├──────────┼──────────┼──────────────┤
│ O(n)     │ 线性阶   │ 顺序查找     │
│          │          │ 遍历数组     │
├──────────┼──────────┼──────────────┤
│ O(n logn)│ 线性对数 │ 快速排序     │
│          │          │ 归并排序     │
│          │          │ 堆排序       │
├──────────┼──────────┼──────────────┤
│ O(n²)    │ 平方阶   │ 冒泡排序     │
│          │          │ 选择排序     │
│          │          │ 插入排序     │
├──────────┼──────────┼──────────────┤
│ O(2ⁿ)    │ 指数阶   │ 递归斐波那契 │
│          │          │ 子集枚举     │
├──────────┼──────────┼──────────────┤
│ O(n!)    │ 阶乘阶   │ 全排列       │
│          │          │ 旅行商问题   │
└──────────┴──────────┴──────────────┘

记忆口诀：
常对线线平方立，指数阶乘最可怕
1 log n n*log n² n³ 2ⁿ n!
```

### 排序算法对比（必背）⭐⭐⭐⭐⭐
```
┌──────┬──────┬──────┬──────┬──────┬──────┐
│算法  │平均  │最好  │最坏  │空间  │稳定性│
├──────┼──────┼──────┼──────┼──────┼──────┤
│冒泡  │O(n²) │O(n)  │O(n²) │O(1)  │稳定  │
├──────┼──────┼──────┼──────┼──────┼──────┤
│选择  │O(n²) │O(n²) │O(n²) │O(1)  │不稳定│
├──────┼──────┼──────┼──────┼──────┼──────┤
│插入  │O(n²) │O(n)  │O(n²) │O(1)  │稳定  │
├──────┼──────┼──────┼──────┼──────┼──────┤
│快速  │O(nlogn)│O(nlogn)│O(n²)│O(logn)│不稳定│
├──────┼──────┼──────┼──────┼──────┼──────┤
│归并  │O(nlogn)│O(nlogn)│O(nlogn)│O(n)│稳定│
├──────┼──────┼──────┼──────┼──────┼──────┤
│堆    │O(nlogn)│O(nlogn)│O(nlogn)│O(1)│不稳定│
└──────┴──────┴──────┴──────┴──────┴──────┘

稳定性记忆：
稳定：冒泡、插入、归并
不稳定：选择、快速、堆

记忆口诀：
冒插归稳定，选快堆不稳
平方级：冒选插
nlogn级：快归堆
```

### 二叉树遍历（必背）⭐⭐⭐⭐⭐
```
前序遍历（Pre-order）：根→左→右
中序遍历（In-order）：左→根→右
后序遍历（Post-order）：左→右→根
层序遍历（Level-order）：逐层从左到右

示例树：
      A
     / \
    B   C
   / \
  D   E

前序：A B D E C（根左右）
中序：D B E A C（左根右）
后序：D E B C A（左右根）
层序：A B C D E（逐层）

记忆口诀：
前序根在前，中序根在中，后序根在后
层序逐层走，从左到右数
```

### 二叉树还原（必背）⭐⭐⭐⭐⭐
```
可以唯一确定二叉树的组合：
1. 前序 + 中序 ✓
2. 后序 + 中序 ✓
3. 层序 + 中序 ✓

不能唯一确定的组合：
1. 前序 + 后序 ✗（无法确定左右子树）
2. 前序 + 层序 ✗
3. 后序 + 层序 ✗

记忆口诀：
中序必须有，前后层任选一
没有中序不能还原树

还原步骤（前序+中序）：
1. 前序第一个是根
2. 在中序中找到根
3. 中序中根左边是左子树，右边是右子树
4. 递归处理左右子树
```

### 图的遍历（必背）⭐⭐⭐⭐⭐
```
深度优先搜索（DFS）：
- 策略：尽可能深地搜索
- 实现：递归或栈
- 特点：沿着一条路走到底，再回溯

广度优先搜索（BFS）：
- 策略：逐层搜索
- 实现：队列
- 特点：先访问邻居，再访问邻居的邻居

对比：
┌────────┬──────┬──────┬──────────┐
│特征    │ DFS  │ BFS  │ 应用     │
├────────┼──────┼──────┼──────────┤
│数据结构│ 栈   │ 队列 │          │
├────────┼──────┼──────┼──────────┤
│搜索策略│ 深度 │ 广度 │          │
├────────┼──────┼──────┼──────────┤
│空间复杂│ O(h) │ O(w) │ h=高度   │
│度      │      │      │ w=宽度   │
├────────┼──────┼──────┼──────────┤
│典型应用│ 拓扑 │ 最短 │          │
│        │ 排序 │ 路径 │          │
└────────┴──────┴──────┴──────────┘

记忆口诀：
DFS用栈深度搜，一条路走到黑头
BFS用队广度搜，逐层访问不回头
```

### 查找算法对比（必背）⭐⭐⭐⭐⭐
```
┌──────────┬──────────┬──────────┬──────────┐
│算法      │ 时间复杂度│ 前提条件 │ 特点     │
├──────────┼──────────┼──────────┼──────────┤
│顺序查找  │ O(n)     │ 无       │ 简单     │
├──────────┼──────────┼──────────┼──────────┤
│二分查找  │ O(log n) │ 有序     │ 快速     │
├──────────┼──────────┼──────────┼──────────┤
│哈希查找  │ O(1)     │ 哈希表   │ 最快     │
├──────────┼──────────┼──────────┼──────────┤
│二叉搜索树│ O(log n) │ 平衡     │ 动态     │
│查找      │ 平均     │          │          │
│          │ O(n)最坏 │          │          │
└──────────┴──────────┴──────────┴──────────┘

记忆口诀：
顺序查找最简单，时间复杂度O(n)
二分查找要有序，对数时间最高效
哈希查找最快速，常数时间O(1)
```

### 最小生成树算法（必背）⭐⭐⭐⭐⭐
```
Prim算法（普里姆）：
- 策略：从顶点出发
- 步骤：
  1. 选择一个起始顶点
  2. 选择与已选顶点相连的最小边
  3. 重复直到所有顶点都被选中
- 适用：稠密图
- 时间复杂度：O(n²)

Kruskal算法（克鲁斯卡尔）：
- 策略：从边出发
- 步骤：
  1. 将所有边按权值排序
  2. 依次选择最小边
  3. 如果不形成回路则加入
  4. 重复直到n-1条边
- 适用：稀疏图
- 时间复杂度：O(e log e)

对比：
┌────────┬──────────┬──────────┐
│特征    │ Prim     │ Kruskal  │
├────────┼──────────┼──────────┤
│出发点  │ 顶点     │ 边       │
├────────┼──────────┼──────────┤
│策略    │ 选最小边 │ 选最小边 │
│        │ 连接已选 │ 不成回路 │
├────────┼──────────┼──────────┤
│适用    │ 稠密图   │ 稀疏图   │
├────────┼──────────┼──────────┤
│复杂度  │ O(n²)    │ O(e loge)│
└────────┴──────────┴──────────┘

记忆口诀：
Prim从点出发选最小，连接已选不成环
Kruskal从边出发排序选，不成回路加进来
```

### 最短路径算法（必背）⭐⭐⭐⭐⭐
```
Dijkstra算法（迪杰斯特拉）：
- 用途：单源最短路径（非负权）
- 策略：贪心算法
- 步骤：
  1. 初始化距离数组
  2. 选择距离最小的未访问顶点
  3. 更新其邻接顶点的距离
  4. 重复直到所有顶点访问完
- 时间复杂度：O(n²)

Floyd算法（弗洛伊德）：
- 用途：所有顶点对最短路径
- 策略：动态规划
- 步骤：
  1. 初始化距离矩阵
  2. 依次考虑每个顶点作为中转点
  3. 更新所有顶点对的距离
- 时间复杂度：O(n³)

对比：
┌────────┬──────────┬──────────┐
│特征    │ Dijkstra │ Floyd    │
├────────┼──────────┼──────────┤
│用途    │ 单源     │ 所有对   │
├────────┼──────────┼──────────┤
│策略    │ 贪心     │ 动态规划 │
├────────┼──────────┼──────────┤
│负权边  │ 不支持   │ 支持     │
├────────┼──────────┼──────────┤
│复杂度  │ O(n²)    │ O(n³)    │
└────────┴──────────┴──────────┘

记忆口诀：
Dijkstra单源贪心法，每次选择最小距
Floyd全对动态规，三重循环找中转
```

## 12.Y 快速记忆口诀大全 ⭐⭐⭐⭐⭐

### 时间复杂度
```
常对线线平方立，指数阶乘最可怕
O(1)常数最快速，O(log n)对数也不错
O(n)线性很常见，O(n log n)快排归并
O(n²)平方冒选插，O(2ⁿ)指数要避免
```

### 排序算法
```
冒泡排序两层循环，相邻比较大的后移
选择排序选最小的，放到前面有序区
插入排序像打扑克，抓一张插入有序区
快速排序选基准值，小的左边大的右边
归并排序分而治之，合并有序两序列
堆排序建大顶堆，堆顶最大交换删除
```

### 排序稳定性
```
冒插归稳定，选快堆不稳
稳定排序：冒泡、插入、归并
不稳定：选择、快速、堆排序
```

### 二叉树遍历
```
前序根在前，中序根在中，后序根在后
前序：根左右，中序：左根右，后序：左右根
层序逐层走，从左到右数
```

### 二叉树还原
```
中序必须有，前后层任选一
前序加中序，后序加中序
层序加中序，都能还原树
只有前后序，无法定左右
```

### 图的遍历
```
DFS用栈深度搜，一条路走到黑头
BFS用队广度搜，逐层访问不回头
深度优先找拓扑，广度优先找最短
```

### 最小生成树
```
Prim从点出发，选择最小连接边
Kruskal从边出发，排序选择不成环
稠密图用Prim，稀疏图用Kruskal
```

### 最短路径
```
Dijkstra单源贪心，每次选择最小距
Floyd全对动态规，三重循环找中转
Dijkstra不支持负权，Floyd可以有负权
```

### 查找算法
```
顺序查找最简单，从头到尾一个个
二分查找要有序，每次折半效率高
哈希查找最快速，直接定位O(1)
```

## 12.Z 典型例题精讲 ⭐⭐⭐⭐⭐

### 例题1：时间复杂度比较 ⭐⭐⭐⭐⭐
以下时间复杂度从小到大排序正确的是？
A. O(n) < O(log n) < O(n²) < O(2ⁿ)
B. O(log n) < O(n) < O(n²) < O(2ⁿ)
C. O(1) < O(n) < O(log n) < O(n²)
D. O(n²) < O(n log n) < O(n) < O(log n)

**解析**：
```
时间复杂度从小到大（从快到慢）：
O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(n³) < O(2ⁿ) < O(n!)

选项分析：
A. O(n) < O(log n)：错误，应该是O(log n) < O(n)
B. O(log n) < O(n) < O(n²) < O(2ⁿ)：正确 ✓
C. O(1) < O(n) < O(log n)：错误，应该是O(log n) < O(n)
D. 完全颠倒，错误

记忆：常对线线平方立指阶
```
**答案**：B

### 例题2：排序算法稳定性 ⭐⭐⭐⭐⭐
以下排序算法中，不稳定的是？
A. 冒泡排序  B. 插入排序  C. 快速排序  D. 归并排序

**解析**：
```
稳定排序：冒泡、插入、归并
不稳定排序：选择、快速、堆

稳定性定义：
相等元素的相对位置在排序前后保持不变

选项分析：
A. 冒泡排序：稳定（相邻比较，相等不交换）
B. 插入排序：稳定（插入时遇到相等元素停止）
C. 快速排序：不稳定（分区时可能改变相对位置）✓
D. 归并排序：稳定（合并时相等元素保持顺序）

记忆口诀：冒插归稳定，选快堆不稳
```
**答案**：C
