# 第11章：面向对象技术 - 知识提纲与重难点

## 📊 章节概况
- **考试重要性**：⭐⭐⭐⭐
- **考试频率**：高（每年8-12分）
- **建议学习时间**：10-12小时
- **主要题型**：选择题、综合应用题、UML图绘制题

---

## 🎯 核心知识点框架

### 重点1：面向对象基本概念 ⭐⭐⭐⭐⭐
**难度**：★★★☆☆
**考试频率**：极高

**面向对象三大特征详解：** ⭐⭐⭐⭐⭐

**1. 封装（Encapsulation）：**
```
定义：将数据和操作数据的方法绑定在一起，隐藏内部实现细节

核心思想：
- 信息隐蔽：对象的内部实现对外部不可见
- 接口统一：通过公共接口访问对象
- 数据保护：防止外部直接访问和修改内部数据

实现机制：
- private（私有）：只能在类内部访问
- public（公有）：可以在任何地方访问
- protected（保护）：可以在类内部和子类中访问

优点：
- 提高安全性
- 降低耦合度
- 便于维护和修改
- 隐藏复杂性
```

**2. 继承（Inheritance）：** ⭐⭐⭐⭐⭐
```
定义：子类自动获得父类的属性和方法，并可以扩展新功能

继承类型：
1. 单继承：一个子类只有一个直接父类
   - Java、C#采用单继承
   
2. 多继承：一个子类可以有多个直接父类
   - C++支持多继承
   - 可能导致二义性问题（菱形继承）

3. 多层继承：形成继承链
   - A → B → C

关键概念：
- 父类/基类/超类（Parent/Base/Super Class）
- 子类/派生类（Child/Derived Class）
- 方法重写（Override）：子类重新定义父类方法
- 方法重载（Overload）：同名方法不同参数

继承的作用：
- 代码复用：避免重复编写相同代码
- 扩展功能：在父类基础上增加新功能
- 建立层次关系：形成类的层次结构
- 实现多态：为多态提供基础
```

**3. 多态（Polymorphism）：** ⭐⭐⭐⭐⭐
```
定义：同一个接口可以有多种不同的实现方式

多态的类型：

1. 重载多态（Overloading）：
   - 同一个类中方法名相同，参数列表不同
   - 编译时确定调用哪个方法（静态绑定）
   - 静态多态/编译时多态
   
   例：
   void print(int x);
   void print(double x);
   void print(String s);

2. 重写多态（Overriding）：
   - 子类重新定义父类的方法
   - 运行时确定调用哪个方法（动态绑定）
   - 动态多态/运行时多态
   
   例：
   class Animal { void sound() {...} }
   class Dog extends Animal { void sound() {...} }  // 重写

3. 参数多态：
   - 泛型编程
   - 类型参数化
   
   例：List<T>

4. 强制多态：
   - 类型转换
   - 自动类型提升

实现机制：
- 虚函数（Virtual Function）
- 动态绑定（Dynamic Binding）
- 后期绑定（Late Binding）

多态的优点：
- 提高代码灵活性
- 增强可扩展性
- 简化代码结构
- 实现接口统一
```

**类与对象详解：** ⭐⭐⭐⭐⭐

**类（Class）：**
```
定义：具有相同属性和方法的对象的抽象和模板

类的组成：
1. 属性（Attribute/Field）：
   - 描述对象的特征
   - 也称为成员变量、数据成员
   
2. 方法（Method）：
   - 描述对象的行为
   - 也称为成员函数、操作
   
3. 构造函数（Constructor）：
   - 创建对象时自动调用
   - 用于初始化对象
   - 方法名与类名相同
   
4. 析构函数（Destructor）：
   - 销毁对象时自动调用
   - 用于释放资源
   - C++中使用，Java有垃圾回收机制

类的特性：
- 抽象性：类是对象的抽象
- 封装性：隐藏实现细节
- 继承性：可以被继承
- 多态性：可以有多种形态
```

**对象（Object）：**
```
定义：类的实例，具有具体的属性值

对象的特征：
1. 唯一性：每个对象都有唯一标识（对象ID）
2. 分类性：每个对象都属于某个类
3. 多态性：对象可以有多种形态
4. 封装性：对象隐藏内部实现

对象的状态：
- 由对象的属性值决定
- 状态可以改变

对象的行为：
- 由对象的方法定义
- 行为可以改变对象状态
```

**消息传递：** ⭐⭐⭐⭐
```
定义：对象间通信的方式

消息的组成：
1. 接收者：接收消息的对象
2. 消息名：要执行的操作（方法名）
3. 参数：操作所需的数据

消息传递过程：
发送者 → 消息 → 接收者 → 执行方法 → 返回结果

特点：
- 对象间通过消息进行通信
- 消息传递是单向的
- 接收者根据消息执行相应方法
```

### 重点2：UML类图 ⭐⭐⭐⭐⭐
**难度**：★★★★☆
**考试频率**：极高

**类图基本表示法：** ⭐⭐⭐⭐⭐

**类的表示：**
```
┌─────────────────┐
│   类名          │  ← 第一层：类名（斜体表示抽象类）
├─────────────────┤
│ - 属性1: 类型   │  ← 第二层：属性
│ # 属性2: 类型   │
│ + 属性3: 类型   │
├─────────────────┤
│ + 方法1()       │  ← 第三层：方法
│ - 方法2()       │
│ # 方法3()       │
└─────────────────┘

可见性符号：
+ public（公有）
- private（私有）
# protected（保护）
~ package（包内可见）
```

**类之间的关系：** ⭐⭐⭐⭐⭐

**1. 泛化关系（Generalization）- 继承：**
```
表示：空心三角箭头，箭头指向父类
符号：───────▷
含义：is-a关系，子类继承父类

例：狗 ───────▷ 动物
    （狗是一种动物）

特点：
- 最强的关系
- 子类拥有父类的所有属性和方法
- 支持多态
```

**2. 实现关系（Realization）：**
```
表示：虚线空心三角箭头，箭头指向接口
符号：- - - - -▷
含义：类实现接口

例：狗 - - - - -▷ 可叫接口
    （狗实现了可叫接口）

特点：
- 类必须实现接口中定义的所有方法
- 一个类可以实现多个接口
```

**3. 关联关系（Association）：** ⭐⭐⭐⭐⭐
```
表示：实线箭头或直线
符号：─────────> 或 ──────────
含义：类之间的引用关系

类型：
1. 单向关联：A ─────────> B
   - A知道B，B不知道A
   
2. 双向关联：A ────────── B
   - A知道B，B也知道A
   
3. 自关联：A ⟲
   - 类与自身关联

多重性标记：
1      ：恰好1个
0..1   ：0个或1个
*      ：0个或多个
1..*   ：1个或多个
n      ：恰好n个
n..m   ：n到m个

例：学生 1───────* 课程
    （一个学生选修多门课程）
```

**4. 聚合关系（Aggregation）：** ⭐⭐⭐⭐⭐
```
表示：空心菱形+实线，菱形指向整体
符号：◇─────────
含义：has-a关系，整体与部分的关系，部分可以独立存在

例：部门 ◇───────── 员工
    （部门有员工，员工可以离开部门独立存在）

特点：
- 弱拥有关系
- 部分可以脱离整体独立存在
- 整体销毁，部分不一定销毁
```

**5. 组合关系（Composition）：** ⭐⭐⭐⭐⭐
```
表示：实心菱形+实线，菱形指向整体
符号：◆─────────
含义：contains-a关系，强整体与部分关系，部分不能独立存在

例：公司 ◆───────── 部门
    （公司包含部门，公司不存在则部门也不存在）

特点：
- 强拥有关系
- 部分不能脱离整体独立存在
- 整体销毁，部分也销毁
- 同一时刻部分只能属于一个整体
```

**6. 依赖关系（Dependency）：**
```
表示：虚线箭头，箭头指向被依赖方
符号：- - - - ->
含义：uses-a关系，一个类使用另一个类

例：人 - - - - -> 汽车
    （人使用汽车）

特点：
- 最弱的关系
- 临时性关联
- 通常表现为方法参数、局部变量、静态方法调用

依赖的形式：
- 方法参数
- 局部变量
- 静态方法调用
- 返回值类型
```

**关系强度排序：** ⭐⭐⭐⭐⭐
```
从强到弱：
泛化 = 实现 > 组合 > 聚合 > 关联 > 依赖

记忆口诀：
"泛实组聚关依"
"继承实现最紧密，组合聚合次之，关联依赖最松散"
```

**典型例题：** ⭐⭐⭐⭐⭐

**题目：** 在UML类图中，以下哪种关系表示"整体与部分"的关系，且部分可以独立于整体存在？
A. 组合  B. 聚合  C. 关联  D. 依赖

**分析：**
- 关键词："整体与部分"、"可以独立存在"
- 组合：部分不能独立存在
- 聚合：部分可以独立存在 ✓
- 关联：一般的引用关系
- 依赖：临时使用关系

**答案：B**

### 重点3：设计模式 ⭐⭐⭐⭐⭐
**难度**：★★★★★
**考试频率**：极高

**设计模式分类：** ⭐⭐⭐⭐⭐

**创建型模式（5种）：**

**1. 单例模式（Singleton）：** ⭐⭐⭐⭐⭐
```
意图：确保一个类只有一个实例，并提供全局访问点

适用场景：
- 系统只需要一个实例（如配置管理器）
- 频繁创建和销毁的对象
- 创建对象耗时过多或耗资源过多

实现要点：
- 私有构造函数
- 私有静态实例变量
- 公有静态获取实例方法

优点：
- 控制实例数目
- 节约系统资源
- 允许可变数目的实例

缺点：
- 没有接口，扩展困难
- 与单一职责原则冲突

典型应用：
- 数据库连接池
- 线程池
- 配置文件读取
- Windows任务管理器
```

**2. 工厂方法模式（Factory Method）：** ⭐⭐⭐⭐⭐
```
意图：定义创建对象的接口，让子类决定实例化哪个类

适用场景：
- 客户端不知道它所需要的对象的类
- 一个类希望由其子类来指定它所创建的对象

结构：
- 抽象工厂：声明工厂方法
- 具体工厂：实现工厂方法，返回具体产品
- 抽象产品：定义产品接口
- 具体产品：实现产品接口

优点：
- 符合开闭原则
- 符合单一职责原则
- 避免创建者和具体产品之间的紧密耦合

缺点：
- 增加系统复杂度
- 增加了类的个数

典型应用：
- JDBC中的Connection
- 日志记录器
- 数据库访问
```

**3. 抽象工厂模式（Abstract Factory）：** ⭐⭐⭐⭐⭐
```
意图：提供一个创建一系列相关或相互依赖对象的接口

与工厂方法的区别：
- 工厂方法：创建一种产品
- 抽象工厂：创建一系列产品（产品族）

适用场景：
- 系统需要独立于产品的创建、组合和表示
- 系统需要由多个产品系列中的一个来配置
- 需要强调一系列相关产品对象的设计以便联合使用

优点：
- 分离了具体的类
- 易于交换产品系列
- 有利于产品的一致性

缺点：
- 难以支持新种类的产品

典型应用：
- 跨平台UI组件
- 数据库访问（支持多种数据库）
```

**4. 建造者模式（Builder）：** ⭐⭐⭐⭐
```
意图：将复杂对象的构建与表示分离，使同样的构建过程可以创建不同的表示

适用场景：
- 创建复杂对象的算法独立于组成对象的部件
- 构造过程必须允许被构造的对象有不同的表示

结构：
- Builder：抽象建造者
- ConcreteBuilder：具体建造者
- Director：指挥者
- Product：产品

优点：
- 建造和表示分离
- 更好的复用性
- 更精细的控制构建过程

缺点：
- 产品必须有共同点
- 内部变化复杂时会有很多建造类

典型应用：
- StringBuilder
- 复杂对象的创建（如汽车、房屋）
```

**5. 原型模式（Prototype）：** ⭐⭐⭐⭐
```
意图：用原型实例指定创建对象的种类，通过复制这些原型创建新对象

适用场景：
- 创建新对象成本较大
- 系统需要独立于产品的创建、组合和表示
- 需要避免创建与产品类层次平行的工厂类层次

实现方式：
- 浅克隆：复制对象及其基本类型属性
- 深克隆：复制对象及其所有引用类型属性

优点：
- 性能优良（直接复制比new快）
- 避免构造函数的约束

缺点：
- 需要为每个类配备克隆方法
- 深克隆实现复杂

典型应用：
- Object.clone()
- 原型管理器
```

**结构型模式（7种）：**

**1. 适配器模式（Adapter）：** ⭐⭐⭐⭐⭐
```
意图：将一个类的接口转换成客户希望的另一个接口

适用场景：
- 想使用一个已存在的类，但其接口不符合需求
- 想创建一个可复用的类，该类可以与不相关的类协同工作

类型：
- 类适配器：通过继承实现
- 对象适配器：通过组合实现

优点：
- 提高类的复用性
- 增加类的透明性
- 灵活性好

缺点：
- 过多使用会使系统凌乱

典型应用：
- InputStreamReader（字节流转字符流）
- 电源适配器
- 读卡器
```

**2. 桥接模式（Bridge）：** ⭐⭐⭐⭐
```
意图：将抽象部分与实现部分分离，使它们可以独立变化

适用场景：
- 不希望在抽象和实现之间有固定的绑定关系
- 抽象和实现都应该可以通过子类扩展
- 对抽象的实现部分的修改不应影响客户端

优点：
- 分离抽象和实现
- 提高可扩展性
- 实现细节对客户透明

缺点：
- 增加系统理解和设计难度

典型应用：
- JDBC驱动
- 图形和绘图程序
```

**3. 组合模式（Composite）：** ⭐⭐⭐⭐⭐
```
意图：将对象组合成树形结构以表示"部分-整体"的层次结构

适用场景：
- 想表示对象的部分-整体层次结构
- 希望用户忽略组合对象与单个对象的不同

结构：
- Component：抽象构件
- Leaf：叶子构件
- Composite：容器构件

优点：
- 定义了包含基本对象和组合对象的类层次结构
- 简化客户端代码
- 易于增加新类型的组件

缺点：
- 设计较复杂
- 不容易限制组合中的构件类型

典型应用：
- 文件系统（文件夹和文件）
- 组织结构树
- GUI容器层次结构
```

**4. 装饰模式（Decorator）：** ⭐⭐⭐⭐⭐
```
意图：动态地给对象添加额外的职责

适用场景：
- 需要扩展一个类的功能
- 动态地为对象添加功能，且可以动态撤销
- 需要通过对现有的一组基本功能进行排列组合产生大量功能

优点：
- 比继承更灵活
- 可以动态扩展功能
- 符合开闭原则

缺点：
- 产生很多小对象
- 多层装饰比较复杂

典型应用：
- Java I/O流（BufferedReader装饰Reader）
- GUI组件的边框、滚动条
```

**5. 外观模式（Facade）：** ⭐⭐⭐⭐
```
意图：为子系统中的一组接口提供一个统一的高层接口

适用场景：
- 为复杂子系统提供简单接口
- 客户端与多个子系统之间存在很大依赖性
- 需要构建一个层次结构的子系统

优点：
- 减少系统相互依赖
- 提高灵活性
- 提高安全性

缺点：
- 不符合开闭原则
- 增加子系统需要修改外观类

典型应用：
- 医院接待员
- 电脑启动过程
```

**6. 享元模式（Flyweight）：** ⭐⭐⭐⭐
```
意图：运用共享技术有效地支持大量细粒度的对象

适用场景：
- 系统中有大量相似对象
- 需要缓冲池的场景
- 对象的大部分状态可以外部化

内部状态：可以共享的状态
外部状态：不可共享的状态

优点：
- 大幅减少对象数量
- 节约内存

缺点：
- 提高系统复杂度
- 需要分离内部和外部状态

典型应用：
- String常量池
- 数据库连接池
- 线程池
```

**7. 代理模式（Proxy）：** ⭐⭐⭐⭐⭐
```
意图：为其他对象提供一种代理以控制对这个对象的访问

代理类型：
1. 远程代理：为远程对象提供代理
2. 虚拟代理：延迟创建开销大的对象
3. 保护代理：控制对原始对象的访问权限
4. 智能引用：在访问对象时执行额外操作

适用场景：
- 需要在访问对象时附加额外操作
- 需要控制对对象的访问

优点：
- 职责清晰
- 高扩展性
- 智能化

缺点：
- 增加系统复杂度
- 可能降低请求速度

典型应用：
- Spring AOP
- RPC远程调用
- 虚拟代理（图片延迟加载）
```

**行为型模式（11种）：**

**1. 观察者模式（Observer）：** ⭐⭐⭐⭐⭐
```
意图：定义对象间一对多的依赖关系，当一个对象状态改变时，所有依赖它的对象都得到通知

适用场景：
- 一个对象的改变需要同时改变其他对象
- 一个对象必须通知其他对象，而它又不知道其他对象是谁

结构：
- Subject：目标（被观察者）
- Observer：观察者
- ConcreteSubject：具体目标
- ConcreteObserver：具体观察者

优点：
- 观察者和被观察者抽象耦合
- 建立触发机制

缺点：
- 如果观察者很多，通知耗时
- 可能导致循环依赖

典型应用：
- MVC模式
- 事件监听机制
- 消息队列
```

**2. 策略模式（Strategy）：** ⭐⭐⭐⭐⭐
```
意图：定义一系列算法，把它们封装起来，并使它们可以相互替换

适用场景：
- 许多相关的类仅仅是行为有异
- 需要使用一个算法的不同变体
- 算法使用客户不应知道的数据

优点：
- 算法可以自由切换
- 避免多重条件判断
- 扩展性良好

缺点：
- 策略类数量增多
- 所有策略类都需要对外暴露

典型应用：
- 排序算法选择
- 支付方式选择
- 压缩算法选择
```

**3. 模板方法模式（Template Method）：** ⭐⭐⭐⭐⭐
```
意图：定义算法骨架，将某些步骤延迟到子类

适用场景：
- 多个子类有公共方法，且逻辑基本相同
- 重要复杂的算法，可以把核心算法设计为模板方法
- 重构时，把相同代码抽取到父类

优点：
- 封装不变部分，扩展可变部分
- 提取公共代码，便于维护
- 行为由父类控制，子类实现

缺点：
- 每个不同实现都需要一个子类
- 增加系统复杂度

典型应用：
- Servlet的service方法
- JUnit的setUp和tearDown
- Spring的JdbcTemplate
```

**快速记忆法：** ⭐⭐⭐⭐⭐

**创建型模式（5种）：**
```
"单工抽建原"
单例、工厂方法、抽象工厂、建造者、原型
```

**结构型模式（7种）：**
```
"适桥组装外享代"
适配器、桥接、组合、装饰、外观、享元、代理
```

**行为型模式（11种）：**
```
"观策模命责链，中介备忘迭访状解"
观察者、策略、模板方法、命令、责任链、
中介者、备忘录、迭代器、访问者、状态、解释器
```

**易错点提醒：** ⭐⭐⭐⭐⭐
1. 聚合和组合的区别：部分能否独立存在
2. 关联和依赖的区别：关联是属性，依赖是参数
3. 工厂方法和抽象工厂：一种产品vs产品族
4. 装饰模式和代理模式：增强功能vs控制访问
5. 策略模式和状态模式：算法切换vs状态切换
6. UML箭头方向：依赖指向被依赖方，继承指向父类
7. 单例模式要考虑线程安全

---

## 📝 学习建议

1. **重点掌握**：
   - 面向对象三大特征
   - UML类图及关系
   - 常用设计模式（单例、工厂、观察者、策略）

2. **学习方法**：
   - 理解概念，不要死记硬背
   - 多画UML图练习
   - 结合实际项目理解设计模式

3. **考试技巧**：
   - UML关系看箭头和菱形
   - 设计模式看应用场景
   - 多态看绑定时机

---

## 🎓 总结

本章重点：
- 面向对象基本概念是基础
- UML类图是考试重点
- 设计模式要理解意图和应用场景
- 关系强度要记牢：泛化>组合>聚合>关联>依赖
