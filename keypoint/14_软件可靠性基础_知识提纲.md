# 14. 软件可靠性基础

## 14.1 软件可靠性基本概念

### 14.1.1 可靠性定义
- **软件可靠性**：在规定条件下、规定时间内，软件不引起系统失效的概率
- **失效**：软件运行结果与预期结果不符
- **故障**：软件中存在的错误或缺陷
- **差错**：人为造成的错误

### 14.1.2 可靠性度量指标
- **MTTF（平均无故障时间）**：Mean Time To Failure
- **MTBF（平均故障间隔时间）**：Mean Time Between Failures
- **MTTR（平均修复时间）**：Mean Time To Repair
- **可用性**：A = MTTF / (MTTF + MTTR)
- **失效率**：λ(t) = f(t) / R(t)

### 14.1.3 可靠性与其他质量属性关系
- 可靠性 vs 正确性
- 可靠性 vs 可用性
- 可靠性 vs 安全性
- 可靠性 vs 性能

## 14.2 软件可靠性模型

### 14.2.1 静态模型
- **错误植入模型**
- **错误移除模型**
- **复杂度模型**
- **输入域模型**

### 14.2.2 动态模型
- **Jelinski-Moranda模型**
  - 假设：故障独立、修复完美
  - λ(t) = φ[N - (i-1)]
- **Littlewood模型**
  - 考虑不完美修复
  - 故障率随时间变化
- **Musa执行时间模型**
  - 基于执行时间而非日历时间
  - λ(τ) = λ₀[1 - F(τ)]

### 14.2.3 模型选择
- 根据开发阶段选择
- 根据数据可用性选择
- 根据精度要求选择

## 14.3 软件可靠性设计

### 14.3.1 容错技术
- **冗余技术**
  - 静态冗余（表决）
  - 动态冗余（备份）
  - 混合冗余
- **恢复块方法**
  - 主块 + 备用块
  - 验收测试
  - 异常处理
- **N版本程序设计**
  - 多个独立版本
  - 表决机制
  - 一致性检查

### 14.3.2 检错技术
- **断言**：程序中的检查点
- **异常处理**：捕获和处理异常
- **防御性编程**：预防性检查
- **错误检测码**：CRC、校验和

### 14.3.3 降低复杂度
- **模块化设计**
- **信息隐藏**
- **接口简化**
- **避免全局变量**

## 14.4 软件可靠性测试

### 14.4.1 可靠性测试方法
- **统计测试**
  - 操作剖面
  - 随机测试
  - 使用模式
- **突变测试**
  - 故障注入
  - 变异算子
  - 等价变异体
- **压力测试**
  - 负载测试
  - 容量测试
  - 稳定性测试

### 14.4.2 测试数据收集
- **失效数据**：时间、类型、严重程度
- **执行时间**：CPU时间、日历时间
- **测试用例数**：执行次数、覆盖率
- **环境数据**：配置、负载、条件

### 14.4.3 可靠性评估
- **数据分析**：拟合模型、参数估计
- **趋势分析**：失效率变化趋势
- **预测**：未来可靠性水平
- **置信度**：评估结果的可信度

## 14.5 软件可靠性增长

### 14.5.1 可靠性增长模型
- **Goel-Okumoto模型**
  - NHPP（非齐次泊松过程）
  - m(t) = a(1 - e^(-bt))
- **S型增长模型**
  - 考虑学习效应
  - 初期增长慢，后期加快
- **对数泊松模型**
  - 适用于长期项目
  - 考虑故障相关性

### 14.5.2 增长策略
- **测试策略优化**
- **缺陷修复优先级**
- **资源分配优化**
- **发布时机决策**

### 14.5.3 增长监控
- **可靠性曲线**
- **失效率趋势**
- **目标达成度**
- **预测准确性**

## 14.6 软件可靠性管理

### 14.6.1 可靠性需求
- **定量需求**：MTTF、可用性指标
- **定性需求**：容错能力、恢复能力
- **约束条件**：成本、时间、资源
- **验收标准**：测试方法、评估准则

### 14.6.2 可靠性计划
- **目标设定**：分阶段目标
- **活动安排**：设计、测试、评估
- **资源配置**：人员、工具、环境
- **风险管理**：识别、评估、应对

### 14.6.3 可靠性保证
- **过程控制**：评审、检查、测试
- **配置管理**：版本控制、变更管理
- **质量审计**：独立评估、符合性检查
- **持续改进**：经验总结、过程优化

## 14.7 高可靠性软件开发

### 14.7.1 形式化方法
- **形式化规约**：Z、VDM、B方法
- **形式化验证**：定理证明、模型检测
- **精化**：从抽象到具体的转换
- **正确性证明**：数学证明

### 14.7.2 安全关键系统
- **DO-178C**：航空软件标准
- **IEC 61508**：功能安全标准
- **ISO 26262**：汽车功能安全
- **SIL等级**：安全完整性等级

### 14.7.3 最佳实践
- **编码标准**：MISRA C、CERT C
- **静态分析**：代码检查、规则验证
- **独立验证与确认**：IV&V
- **可追溯性**：需求到代码的追踪

## 14.8 可靠性工具与技术

### 14.8.1 建模工具
- **可靠性框图**：RBD
- **故障树分析**：FTA
- **马尔可夫模型**：状态转移
- **Petri网**：并发系统建模

### 14.8.2 测试工具
- **故障注入工具**：模拟故障
- **负载生成器**：压力测试
- **监控工具**：运行时监控
- **分析工具**：数据分析、可视化

### 14.8.3 评估工具
- **SMERFS**：多模型评估
- **CASRE**：可靠性估计
- **SoRel**：可靠性分析
- **自定义工具**：特定需求

## 14.9 实际应用案例

### 14.9.1 电信系统
- **高可用性要求**：99.999%
- **冗余设计**：主备切换
- **故障恢复**：快速切换
- **监控告警**：实时监控

### 14.9.2 金融系统
- **数据一致性**：事务处理
- **容错机制**：多副本
- **灾难恢复**：异地备份
- **审计追踪**：操作记录

### 14.9.3 医疗设备
- **安全关键**：生命相关
- **认证要求**：FDA、CE
- **风险管理**：ISO 14971
- **可追溯性**：完整记录

## 14.10 考试要点总结

### 14.10.1 核心概念
- 可靠性定义和度量指标
- MTTF、MTBF、MTTR计算
- 可用性计算公式
- 失效率和可靠度关系

### 14.10.2 常见模型
- Jelinski-Moranda模型特点
- Goel-Okumoto模型应用
- 可靠性增长曲线
- 模型参数估计

### 14.10.3 设计技术
- 容错技术分类和应用
- N版本程序设计原理
- 恢复块方法步骤
- 冗余技术比较

### 14.10.4 测试方法
- 统计测试和操作剖面
- 可靠性测试数据收集
- 可靠性评估方法
- 测试充分性判断

### 14.10.5 计算题型
- 可用性计算：A = MTTF/(MTTF+MTTR)
- 失效率计算：λ = 失效次数/总时间
- 可靠度计算：R(t) = e^(-λt)
- 串并联系统可靠性

## 14.11 典型例题

### 例题1：可用性计算 ⭐⭐⭐⭐⭐
某系统MTTF=1000小时，MTTR=10小时，求可用性。
**解答**：A = 1000/(1000+10) = 0.9901 = 99.01%

### 例题2：串联系统可靠性 ⭐⭐⭐⭐⭐
两个模块串联，可靠性分别为0.9和0.95，求系统可靠性。
**解答**：R_系统 = 0.9 × 0.95 = 0.855

### 例题3：并联系统可靠性 ⭐⭐⭐⭐⭐
两个模块并联，可靠性均为0.8，求系统可靠性。
**解答**：R_系统 = 1 - (1-0.8)² = 1 - 0.04 = 0.96

### 例题4：失效率计算 ⭐⭐⭐⭐
系统运行10000小时，发生5次失效，求平均失效率。
**解答**：λ = 5/10000 = 0.0005次/小时 = 5×10⁻⁴/小时

### 例题5：混合系统可靠性 ⭐⭐⭐⭐⭐
系统由3个模块组成：A和B并联后与C串联，RA=0.9，RB=0.8，RC=0.95，求系统可靠性。
**解答**：
```
步骤1：计算A、B并联的可靠性
R_AB = 1 - (1-0.9)(1-0.8) = 1 - 0.1×0.2 = 1 - 0.02 = 0.98

步骤2：R_AB与C串联
R_系统 = R_AB × RC = 0.98 × 0.95 = 0.931
```
**答案**：0.931

### 例题6：N版本程序设计 ⭐⭐⭐⭐
采用3版本程序设计，每个版本可靠性为0.9，采用多数表决，求系统可靠性。
**解答**：
```
系统正常工作条件：至少2个版本正常
P(3个都正常) = 0.9³ = 0.729
P(恰好2个正常) = C(3,2) × 0.9² × 0.1 = 3 × 0.81 × 0.1 = 0.243
R_系统 = 0.729 + 0.243 = 0.972
```
**答案**：0.972

### 例题7：MTBF与可用性关系 ⭐⭐⭐⭐⭐
某系统可用性为99.9%，MTTR=1小时，求MTBF。
**解答**：
```
A = MTTF/(MTTF+MTTR) = 0.999
设MTTF = x
x/(x+1) = 0.999
x = 0.999(x+1)
x = 0.999x + 0.999
0.001x = 0.999
x = 999小时

MTBF = MTTF + MTTR = 999 + 1 = 1000小时
```
**答案**：1000小时

---

**学习建议**：
1. 重点掌握可靠性度量指标的计算
2. 理解各种可靠性模型的适用场景
3. 熟悉容错技术的原理和应用
4. 练习串并联系统可靠性计算
5. 关注实际系统的可靠性设计案例


## 14.12 重要公式速查 ⭐⭐⭐⭐⭐

### 基本公式
```
1. MTBF = MTTF + MTTR

2. 可用性 A = MTTF/(MTTF+MTTR) = MTTF/MTBF

3. 失效率 λ = 失效次数/总运行时间

4. 可靠度 R(t) = e^(-λt)  （指数分布）

5. MTTF = 1/λ  （指数分布）
```

### 串并联公式
```
6. 串联系统：R_串 = R₁ × R₂ × ... × Rₙ

7. 并联系统：R_并 = 1 - (1-R₁)(1-R₂)...(1-Rₙ)

8. n个相同部件并联：R_并 = 1 - (1-R)ⁿ

9. n个相同部件串联：R_串 = Rⁿ
```

### 冗余系统公式
```
10. 三模冗余（TMR）：
    R_TMR = 3R² - 2R³  （R为单模块可靠性）
    
11. N版本程序（N为奇数，多数表决）：
    R = Σ C(N,k) × R^k × (1-R)^(N-k)  （k从⌈N/2⌉到N）
```

## 14.13 快速记忆口诀 ⭐⭐⭐⭐⭐

### 可靠性指标
```
MTTF无故障，MTTR修复忙
MTBF两故障，可用性最强
分子是MTTF，分母加MTTR
```

### 串并联记忆
```
串联相乘靠谱低，一坏全坏要注意
并联相加靠谱高，一好就好真奇妙
并联公式用失效，1减失效积就对
```

### 容错技术
```
冗余技术三兄弟：静态动态和混合
静态表决不切换，动态备份要切换
N版本独立做，恢复块串行跑
```

### 可靠性模型
```
JM模型最简单，故障独立修复完
Goel模型用泊松，增长曲线指数型
Musa模型看执行，时间单位要分清
```

## 14.14 易错点提醒 ⭐⭐⭐⭐⭐

### 易错点1：MTBF与MTTF混淆
```
❌ 错误：MTBF就是MTTF
✅ 正确：
   - MTTF：不可修复系统，从开始到故障
   - MTBF：可修复系统，两次故障之间
   - MTBF = MTTF + MTTR
```

### 易错点2：可用性计算错误
```
❌ 错误：A = MTTR/(MTTF+MTTR)
✅ 正确：A = MTTF/(MTTF+MTTR)
记忆：分子是"好"的时间（MTTF）
```

### 易错点3：并联公式直接相加
```
❌ 错误：R_并 = R₁ + R₂
✅ 正确：R_并 = 1 - (1-R₁)(1-R₂)
原因：概率不能直接相加超过1
```

### 易错点4：串并联混合系统计算顺序
```
❌ 错误：从左到右依次计算
✅ 正确：
   1. 先识别最内层的串联或并联
   2. 逐层向外计算
   3. 画出等效图辅助理解
```

### 易错点5：N版本程序可靠性
```
❌ 错误：R_N版本 = 1 - (1-R)ⁿ
✅ 正确：需要考虑多数表决
   3版本：R = 3R² - 2R³
   5版本：R = 10R³ - 15R⁴ + 6R⁵
```

### 易错点6：容错技术分类
```
❌ 错误：冗余就是备份
✅ 正确：
   - 静态冗余：表决，不切换（如TMR）
   - 动态冗余：备份，需切换（如主备）
   - 混合冗余：结合两者
```

### 易错点7：可靠性与可用性
```
❌ 错误：可靠性高就是可用性高
✅ 正确：
   - 可靠性：不出故障的能力
   - 可用性：出故障后快速恢复的能力
   - 可用性 = f(可靠性, 可维修性)
```

## 14.15 考试答题技巧 ⭐⭐⭐⭐⭐

### 技巧1：识别题型
```
关键词识别：
- "MTTF"、"MTTR"、"可用性" → 基本公式题
- "串联"、"并联" → 系统可靠性计算
- "冗余"、"备份" → 容错技术题
- "测试"、"故障" → 可靠性测试题
```

### 技巧2：计算题步骤
```
1. 写出已知条件
2. 写出求解目标
3. 选择合适公式
4. 代入计算
5. 检查结果合理性（0≤R≤1，0≤A≤1）
```

### 技巧3：混合系统简化
```
1. 画出系统框图
2. 标注各部件可靠性
3. 从内到外逐层计算
4. 用等效部件替代已计算部分
```

### 技巧4：快速估算
```
- 串联系统：R_串 < min(R₁,R₂,...,Rₙ)
- 并联系统：R_并 > max(R₁,R₂,...,Rₙ)
- 用于排除错误选项
```

### 技巧5：单位换算
```
注意时间单位：
- 小时 ↔ 天：×24 或 ÷24
- 天 ↔ 年：×365 或 ÷365
- 保持单位一致性
```

## 14.16 真题精选 ⭐⭐⭐⭐⭐

### 真题1（2022年）
某系统由3个相同模块并联组成，每个模块的可靠性为0.8，则系统可靠性为（）。
A. 0.8  B. 0.896  C. 0.992  D. 2.4

**解析**：
```
并联系统：R = 1 - (1-R)ⁿ
R = 1 - (1-0.8)³
R = 1 - 0.2³
R = 1 - 0.008
R = 0.992
```
**答案**：C

### 真题2（2021年）
某系统MTBF=500小时，MTTR=5小时，则系统可用性为（）。
A. 0.99  B. 0.95  C. 0.90  D. 0.85

**解析**：
```
MTTF = MTBF - MTTR = 500 - 5 = 495小时
A = MTTF/(MTTF+MTTR) = 495/500 = 0.99
```
**答案**：A

### 真题3（2020年）
采用三模冗余（TMR）技术，每个模块可靠性为0.9，则系统可靠性为（）。
A. 0.9  B. 0.927  C. 0.972  D. 0.999

**解析**：
```
TMR公式：R = 3R² - 2R³
R = 3×0.9² - 2×0.9³
R = 3×0.81 - 2×0.729
R = 2.43 - 1.458
R = 0.972
```
**答案**：C

### 真题4（2019年）
以下关于软件可靠性的叙述，错误的是（）。
A. N版本程序设计属于静态冗余
B. 恢复块方法属于动态冗余
C. 提高可用性可以减少MTTR
D. 串联系统可靠性高于单个部件

**解析**：
```
A. 正确：N版本采用表决，属于静态冗余
B. 正确：恢复块需要切换，属于动态冗余
C. 正确：A=MTTF/(MTTF+MTTR)，减少MTTR可提高A
D. 错误：串联系统可靠性低于任何单个部件
```
**答案**：D

## 14.17 学习路线图 ⭐⭐⭐⭐

### 第一阶段：基础概念（2小时）
- [ ] 理解可靠性定义
- [ ] 掌握MTTF、MTTR、MTBF、可用性
- [ ] 记忆基本公式
- [ ] 完成基础计算题5道

### 第二阶段：系统可靠性（2小时）
- [ ] 掌握串联系统计算
- [ ] 掌握并联系统计算
- [ ] 练习混合系统计算
- [ ] 完成系统计算题10道

### 第三阶段：容错技术（1小时）
- [ ] 理解冗余技术分类
- [ ] 掌握TMR计算
- [ ] 了解N版本程序设计
- [ ] 完成容错技术题5道

### 第四阶段：综合应用（1小时）
- [ ] 做真题5套
- [ ] 总结易错点
- [ ] 复习公式和口诀
- [ ] 模拟考试

---

**本章学习建议**：
1. 重点掌握可靠性计算公式，多做练习题
2. 理解串并联系统的本质区别
3. 记住常用的快速计算方法
4. 注意单位换算和结果合理性检查
5. 容错技术重在理解原理，不要死记硬背
