# 第12章：数据结构与算法 - 知识提纲与重难点

## 📊 章节概况
- **考试重要性**：⭐⭐⭐⭐⭐
- **考试频率**：极高（每年10-15分）
- **建议学习时间**：15-18小时
- **主要题型**：选择题、算法分析题、综合应用题

---

## 🎯 核心知识点框架

### 重点1：时间复杂度与空间复杂度 ⭐⭐⭐⭐⭐
**难度**：★★★★☆
**考试频率**：极高

**时间复杂度详解：** ⭐⭐⭐⭐⭐

**定义：**
```
时间复杂度：算法执行时间随问题规模n增长的增长率
记法：T(n) = O(f(n))
```

**常见时间复杂度：**
```
从优到劣排序：
O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(n³) < O(2ⁿ) < O(n!)

1. O(1) - 常数阶：
   - 执行时间不随n变化
   - 例：数组按索引访问、简单赋值

2. O(log n) - 对数阶：
   - 每次减少一半
   - 例：二分查找、二叉搜索树查找

3. O(n) - 线性阶：
   - 执行次数与n成正比
   - 例：遍历数组、顺序查找

4. O(n log n) - 线性对数阶：
   - 例：快速排序、归并排序、堆排序

5. O(n²) - 平方阶：
   - 两层嵌套循环
   - 例：冒泡排序、选择排序、插入排序

6. O(n³) - 立方阶：
   - 三层嵌套循环
   - 例：矩阵乘法

7. O(2ⁿ) - 指数阶：
   - 例：递归求斐波那契数列

8. O(n!) - 阶乘阶：
   - 例：旅行商问题的暴力解法
```

**时间复杂度计算方法：** ⭐⭐⭐⭐⭐

**规则1：加法规则**
```
T(n) = T1(n) + T2(n) = O(max(f(n), g(n)))
取最大的复杂度

例：
for (i = 0; i < n; i++)     // O(n)
    ...
for (j = 0; j < n*n; j++)   // O(n²)
    ...
总复杂度：O(n²)
```

**规则2：乘法规则**
```
T(n) = T1(n) × T2(n) = O(f(n) × g(n))

例：
for (i = 0; i < n; i++)           // O(n)
    for (j = 0; j < n; j++)       // O(n)
        ...
总复杂度：O(n²)
```

**规则3：常数忽略**
```
O(3n) = O(n)
O(n/2) = O(n)
O(100) = O(1)
```

**典型例题：** ⭐⭐⭐⭐⭐

**例题1：** 计算以下代码的时间复杂度
```c
for (i = 1; i < n; i = i * 2) {
    printf("%d", i);
}
```

**分析：**
```
i的取值：1, 2, 4, 8, ..., 2^k
当2^k = n时，k = log₂n
循环执行log₂n次
```

**答案：O(log n)**

**例题2：** 计算以下代码的时间复杂度
```c
for (i = 0; i < n; i++) {
    for (j = 0; j < i; j++) {
        printf("%d", i);
    }
}
```

**分析：**
```
外层循环n次
内层循环次数：0 + 1 + 2 + ... + (n-1) = n(n-1)/2
总次数：n²/2 - n/2
```

**答案：O(n²)**

### 重点2：线性表 ⭐⭐⭐⭐⭐
**难度**：★★★☆☆
**考试频率**：极高

**顺序表（数组）：** ⭐⭐⭐⭐⭐

**特点：**
```
存储方式：连续存储
优点：
- 随机访问，O(1)时间
- 存储密度高
- 无需额外空间存储关系

缺点：
- 插入删除需要移动元素，O(n)时间
- 需要预分配空间
- 空间利用率可能不高
```

**基本操作时间复杂度：**
```
访问：O(1)
查找：O(n)（顺序查找）
插入：O(n)（平均移动n/2个元素）
删除：O(n)（平均移动n/2个元素）
```

**链表：** ⭐⭐⭐⭐⭐

**单链表：**
```
结构：
struct Node {
    int data;        // 数据域
    Node* next;      // 指针域
};

特点：
- 非连续存储
- 动态分配空间
- 插入删除方便

基本操作时间复杂度：
访问：O(n)（需要遍历）
查找：O(n)
插入：O(1)（已知位置）
删除：O(1)（已知位置）
```

**双向链表：**
```
结构：
struct Node {
    int data;
    Node* prev;      // 前驱指针
    Node* next;      // 后继指针
};

特点：
- 可以双向遍历
- 删除操作更方便
- 空间开销更大
```

**循环链表：**
```
特点：
- 尾节点指向头节点
- 可以从任意节点访问所有节点
```

**顺序表vs链表对比：** ⭐⭐⭐⭐⭐

| 操作 | 顺序表 | 链表 |
|------|--------|------|
| 随机访问 | O(1) | O(n) |
| 插入删除 | O(n) | O(1) |
| 空间分配 | 静态 | 动态 |
| 存储密度 | 高 | 低 |
| 适用场景 | 查询多 | 插入删除多 |

### 重点3：栈和队列 ⭐⭐⭐⭐⭐
**难度**：★★★☆☆
**考试频率**：极高

**栈（Stack）：** ⭐⭐⭐⭐⭐

**定义：**
```
后进先出（LIFO - Last In First Out）
只能在一端（栈顶）进行插入和删除操作
```

**基本操作：**
```
push(x)：入栈，将元素x压入栈顶
pop()：出栈，删除并返回栈顶元素
top()：取栈顶元素，不删除
isEmpty()：判断栈是否为空
```

**应用场景：** ⭐⭐⭐⭐⭐
```
1. 表达式求值：
   - 中缀表达式转后缀表达式
   - 后缀表达式求值

2. 括号匹配检查

3. 函数调用：
   - 递归调用
   - 函数调用栈

4. 深度优先搜索（DFS）

5. 浏览器的后退功能

6. 撤销操作（Undo）
```

**典型例题：** ⭐⭐⭐⭐⭐

**例题：** 中缀表达式"A+B*C"转换为后缀表达式

**步骤：**
```
1. 遇到操作数，直接输出
2. 遇到运算符：
   - 若栈空或栈顶是'('，入栈
   - 若优先级大于栈顶，入栈
   - 否则，弹出栈顶并输出，重复比较
3. 遇到'('，入栈
4. 遇到')'，弹出直到'('
5. 表达式结束，弹出所有运算符

转换过程：
输入：A + B * C
步骤：
A：输出A
+：入栈+
B：输出B
*：优先级高于+，入栈*
C：输出C
结束：弹出*，弹出+

结果：ABC*+
```

**队列（Queue）：** ⭐⭐⭐⭐⭐

**定义：**
```
先进先出（FIFO - First In First Out）
在队尾插入，在队头删除
```

**基本操作：**
```
enqueue(x)：入队，在队尾插入元素x
dequeue()：出队，删除并返回队头元素
front()：取队头元素，不删除
isEmpty()：判断队列是否为空
```

**循环队列：** ⭐⭐⭐⭐⭐
```
解决假溢出问题

关键公式：
队空条件：front == rear
队满条件：(rear + 1) % maxSize == front
队列长度：(rear - front + maxSize) % maxSize
入队：rear = (rear + 1) % maxSize
出队：front = (front + 1) % maxSize

注意：需要牺牲一个存储单元来区分队空和队满
```

**应用场景：**
```
1. 广度优先搜索（BFS）
2. 打印队列
3. 消息队列
4. 任务调度
5. 缓冲区管理
```

### 重点4：树与二叉树 ⭐⭐⭐⭐⭐
**难度**：★★★★★
**考试频率**：极高

**树的基本概念：** ⭐⭐⭐⭐⭐

**术语：**
```
节点的度：节点的子树个数
树的度：树中节点度的最大值
叶子节点：度为0的节点
分支节点：度不为0的节点
节点的层次：从根开始，根为第1层
树的深度/高度：树中节点的最大层次
节点的高度：从该节点到叶子节点的最长路径
节点的深度：从根节点到该节点的路径长度
```

**重要性质：**
```
1. 节点数 = 所有节点的度数之和 + 1
2. 度为m的树中第i层最多有m^(i-1)个节点
3. 高度为h的m叉树最多有(m^h - 1)/(m - 1)个节点
```

**二叉树：** ⭐⭐⭐⭐⭐

**定义：**
```
每个节点最多有两个子树的树
左子树和右子树有顺序之分
```

**二叉树的性质：** ⭐⭐⭐⭐⭐
```
性质1：第i层最多有2^(i-1)个节点（i≥1）

性质2：深度为k的二叉树最多有2^k - 1个节点

性质3：对任何二叉树，若叶子节点数为n₀，度为2的节点数为n₂，
       则n₀ = n₂ + 1

性质4：具有n个节点的完全二叉树深度为⌊log₂n⌋ + 1

性质5：完全二叉树中，若节点编号为i（从1开始）：
       - 父节点编号：⌊i/2⌋
       - 左孩子编号：2i
       - 右孩子编号：2i + 1
```

**满二叉树：**
```
定义：深度为k且有2^k - 1个节点的二叉树
特点：每层节点数都达到最大值
```

**完全二叉树：** ⭐⭐⭐⭐⭐
```
定义：除最后一层外，其他层节点数都达到最大，
      且最后一层节点都集中在左边

特点：
- 叶子节点只出现在最后两层
- 最后一层叶子节点集中在左边
- 若有度为1的节点，只可能有一个，且只有左孩子
```

**二叉树的遍历：** ⭐⭐⭐⭐⭐

**前序遍历（根左右）：**
```
递归算法：
void preOrder(Node* root) {
    if (root == NULL) return;
    visit(root);           // 访问根节点
    preOrder(root->left);  // 遍历左子树
    preOrder(root->right); // 遍历右子树
}
```

**中序遍历（左根右）：**
```
递归算法：
void inOrder(Node* root) {
    if (root == NULL) return;
    inOrder(root->left);   // 遍历左子树
    visit(root);           // 访问根节点
    inOrder(root->right);  // 遍历右子树
}
```

**后序遍历（左右根）：**
```
递归算法：
void postOrder(Node* root) {
    if (root == NULL) return;
    postOrder(root->left);  // 遍历左子树
    postOrder(root->right); // 遍历右子树
    visit(root);            // 访问根节点
}
```

**层次遍历：**
```
使用队列实现：
void levelOrder(Node* root) {
    if (root == NULL) return;
    Queue q;
    q.enqueue(root);
    while (!q.isEmpty()) {
        Node* node = q.dequeue();
        visit(node);
        if (node->left) q.enqueue(node->left);
        if (node->right) q.enqueue(node->right);
    }
}
```

**遍历序列还原二叉树：** ⭐⭐⭐⭐⭐

**规则：**
```
1. 前序+中序 → 唯一确定二叉树
2. 后序+中序 → 唯一确定二叉树
3. 前序+后序 → 不能唯一确定（除非是满二叉树）
4. 层次+中序 → 唯一确定二叉树
```

**例题：** 已知前序序列：ABDECF，中序序列：DBEAFC，求后序序列

**步骤：**
```
1. 前序第一个A是根节点
2. 在中序中找到A，左边DBE是左子树，右边FC是右子树
3. 前序中BDE对应左子树，CF对应右子树
4. 递归处理左子树：
   前序：BDE，中序：DBE
   B是根，D是左子树，E是右子树
5. 递归处理右子树：
   前序：CF，中序：FC
   C是根，F是左子树
6. 后序遍历：左右根
   左子树：DEB
   右子树：FC
   根：A
```

**答案：DEBFCA**

**二叉搜索树（BST）：** ⭐⭐⭐⭐⭐

**定义：**
```
1. 若左子树不空，则左子树所有节点值 < 根节点值
2. 若右子树不空，则右子树所有节点值 > 根节点值
3. 左右子树也都是二叉搜索树
```

**性质：**
```
中序遍历BST得到递增序列
```

**操作时间复杂度：**
```
平均情况：O(log n)
最坏情况：O(n)（退化成链表）
```

**平衡二叉树（AVL树）：** ⭐⭐⭐⭐

**定义：**
```
1. 是二叉搜索树
2. 任意节点的左右子树高度差不超过1
```

**平衡因子：**
```
BF = 左子树高度 - 右子树高度
AVL树中：BF ∈ {-1, 0, 1}
```

**旋转操作：**
```
LL型：右旋
RR型：左旋
LR型：先左旋后右旋
RL型：先右旋后左旋
```

### 重点5：图 ⭐⭐⭐⭐⭐
**难度**：★★★★★
**考试频率**：高

**图的基本概念：** ⭐⭐⭐⭐⭐

**术语：**
```
顶点（Vertex）：图中的节点
边（Edge）：连接两个顶点的线
度（Degree）：与顶点相连的边数
  - 无向图：度 = 入度 + 出度
  - 有向图：入度、出度
路径：顶点序列
路径长度：路径上边的数目
简单路径：顶点不重复的路径
回路/环：起点和终点相同的路径
连通图：任意两顶点都有路径
强连通图：有向图中任意两顶点双向可达
```

**图的存储：** ⭐⭐⭐⭐⭐

**邻接矩阵：**
```
用二维数组存储
A[i][j] = 1表示顶点i和j之间有边

优点：
- 判断两顶点是否有边：O(1)
- 适合稠密图

缺点：
- 空间复杂度：O(n²)
- 不适合稀疏图

无向图邻接矩阵：对称矩阵
有向图邻接矩阵：不一定对称
```

**邻接表：**
```
用链表存储每个顶点的邻接顶点

优点：
- 空间复杂度：O(n + e)
- 适合稀疏图

缺点：
- 判断两顶点是否有边：O(度)
```

**图的遍历：** ⭐⭐⭐⭐⭐

**深度优先搜索（DFS）：**
```
思想：尽可能深地搜索

实现：使用栈（递归）

时间复杂度：
- 邻接矩阵：O(n²)
- 邻接表：O(n + e)

应用：
- 判断图的连通性
- 求连通分量
- 拓扑排序
- 判断是否有环
```

**广度优先搜索（BFS）：**
```
思想：逐层搜索

实现：使用队列

时间复杂度：
- 邻接矩阵：O(n²)
- 邻接表：O(n + e)

应用：
- 求最短路径（无权图）
- 判断图的连通性
- 层次遍历
```

**最小生成树：** ⭐⭐⭐⭐⭐

**定义：**
```
连通图的生成树中，边的权值之和最小的生成树

性质：
- n个顶点的生成树有n-1条边
- 生成树是连通的
- 生成树无环
```

**Prim算法：**
```
思想：从一个顶点开始，逐步扩展生成树

步骤：
1. 选择任意顶点作为起点
2. 选择与当前生成树相连的最小权值边
3. 将该边和顶点加入生成树
4. 重复步骤2-3，直到所有顶点都在生成树中

时间复杂度：O(n²)
适用：稠密图
```

**Kruskal算法：**
```
思想：按边的权值从小到大选择边

步骤：
1. 将所有边按权值排序
2. 依次选择权值最小的边
3. 若该边不形成环，则加入生成树
4. 重复步骤2-3，直到有n-1条边

时间复杂度：O(e log e)
适用：稀疏图
```

**最短路径：** ⭐⭐⭐⭐⭐

**Dijkstra算法（单源最短路径）：**
```
思想：贪心算法，逐步确定最短路径

条件：不能有负权边

步骤：
1. 初始化：源点距离为0，其他为∞
2. 选择未访问顶点中距离最小的顶点
3. 更新该顶点邻接顶点的距离
4. 标记该顶点为已访问
5. 重复步骤2-4，直到所有顶点都访问

时间复杂度：O(n²)
```

**Floyd算法（全源最短路径）：**
```
思想：动态规划

可以处理负权边（但不能有负权回路）

步骤：
对于每对顶点(i,j)，尝试通过中间顶点k
若dist[i][k] + dist[k][j] < dist[i][j]
则更新dist[i][j]

时间复杂度：O(n³)
```

### 重点6：排序算法 ⭐⭐⭐⭐⭐
**难度**：★★★★★
**考试频率**：极高

**排序算法对比表：** ⭐⭐⭐⭐⭐

| 算法 | 平均时间 | 最坏时间 | 最好时间 | 空间 | 稳定性 |
|------|----------|----------|----------|------|--------|
| 冒泡排序 | O(n²) | O(n²) | O(n) | O(1) | 稳定 |
| 选择排序 | O(n²) | O(n²) | O(n²) | O(1) | 不稳定 |
| 插入排序 | O(n²) | O(n²) | O(n) | O(1) | 稳定 |
| 希尔排序 | O(n^1.3) | O(n²) | O(n) | O(1) | 不稳定 |
| 快速排序 | O(n log n) | O(n²) | O(n log n) | O(log n) | 不稳定 |
| 归并排序 | O(n log n) | O(n log n) | O(n log n) | O(n) | 稳定 |
| 堆排序 | O(n log n) | O(n log n) | O(n log n) | O(1) | 不稳定 |
| 计数排序 | O(n+k) | O(n+k) | O(n+k) | O(k) | 稳定 |
| 基数排序 | O(d(n+k)) | O(d(n+k)) | O(d(n+k)) | O(n+k) | 稳定 |

**快速排序：** ⭐⭐⭐⭐⭐
```
思想：分治法

步骤：
1. 选择基准元素（pivot）
2. 分区：小于pivot的放左边，大于的放右边
3. 递归排序左右两部分

时间复杂度：
- 平均：O(n log n)
- 最坏：O(n²)（已排序或逆序）
- 最好：O(n log n)

空间复杂度：O(log n)（递归栈）

稳定性：不稳定

优化：
- 三数取中法选择pivot
- 小数组用插入排序
- 尾递归优化
```

**归并排序：** ⭐⭐⭐⭐⭐
```
思想：分治法

步骤：
1. 分解：将数组分成两半
2. 递归排序两半
3. 合并：将两个有序数组合并

时间复杂度：O(n log n)（所有情况）

空间复杂度：O(n)

稳定性：稳定

特点：
- 时间复杂度稳定
- 需要额外空间
- 适合链表排序
```

**堆排序：** ⭐⭐⭐⭐⭐
```
思想：利用堆的性质

步骤：
1. 建立大顶堆
2. 将堆顶（最大值）与末尾交换
3. 调整剩余元素为大顶堆
4. 重复步骤2-3

时间复杂度：O(n log n)（所有情况）

空间复杂度：O(1)

稳定性：不稳定

特点：
- 原地排序
- 时间复杂度稳定
- 不适合小数据量
```

**快速记忆法：** ⭐⭐⭐⭐⭐

**时间复杂度：**
```
"冒选插"：O(n²)
"快归堆"：O(n log n)
"计基桶"：O(n)（特殊情况）
```

**稳定性：**
```
稳定："冒插归基计"（冒泡、插入、归并、基数、计数）
不稳定："选快希堆"（选择、快速、希尔、堆）
```

**空间复杂度：**
```
O(1)："冒选插希堆"
O(log n)："快"
O(n)："归"
```

**易错点提醒：** ⭐⭐⭐⭐⭐
1. 完全二叉树性质：n₀ = n₂ + 1
2. 循环队列判满：(rear + 1) % maxSize == front
3. 前序+后序不能唯一确定二叉树
4. BST的中序遍历是递增序列
5. 快速排序最坏情况是O(n²)
6. 归并排序需要O(n)额外空间
7. 堆排序不稳定
8. Dijkstra不能处理负权边

---

## 📝 学习建议

1. **重点掌握**：
   - 时间复杂度计算
   - 二叉树遍历和还原
   - 图的遍历算法
   - 常用排序算法

2. **学习方法**：
   - 多做题，熟练计算
   - 画图理解算法过程
   - 对比记忆相似概念

3. **考试技巧**：
   - 复杂度看循环层数
   - 遍历还原画树图
   - 排序看稳定性和复杂度

---

## 🎓 总结

本章重点：
- 时间复杂度是基础，必须熟练计算
- 二叉树是重点，遍历和还原要掌握
- 图的算法要理解思想
- 排序算法要记住特点和复杂度
