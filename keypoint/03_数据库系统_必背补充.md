# 第3章：数据库系统 - 必背补充内容

## 3.X 必背知识点速查 ⭐⭐⭐⭐⭐

### 范式判断（必背）⭐⭐⭐⭐⭐
```
┌────┬──────┬──────────────┬──────────────┐
│范式│名称  │ 要求         │ 消除的依赖   │
├────┼──────┼──────────────┼──────────────┤
│1NF │第一  │ 属性不可分   │ 无           │
│    │范式  │ 原子性       │              │
├────┼──────┼──────────────┼──────────────┤
│2NF │第二  │ 满足1NF      │ 消除部分     │
│    │范式  │ 非主属性完全 │ 函数依赖     │
│    │      │ 依赖于码     │              │
├────┼──────┼──────────────┼──────────────┤
│3NF │第三  │ 满足2NF      │ 消除传递     │
│    │范式  │ 非主属性不传 │ 函数依赖     │
│    │      │ 递依赖于码   │              │
├────┼──────┼──────────────┼──────────────┤
│BCNF│BC    │ 满足3NF      │ 消除主属性   │
│    │范式  │ 所有决定因素 │ 对码的部分   │
│    │      │ 都包含候选键 │ 和传递依赖   │
└────┴──────┴──────────────┴──────────────┘

范式关系：1NF ⊃ 2NF ⊃ 3NF ⊃ BCNF

记忆口诀：
1NF属性不可分，原子性是关键
2NF消除部分依赖，非主完全依赖码
3NF消除传递依赖，非主不传递于码
BCNF决定因素强，都要包含候选键
```

### 函数依赖类型（必背）⭐⭐⭐⭐⭐
```
完全函数依赖：
- 定义：Y完全依赖于X，X的任何真子集都不能决定Y
- 记号：X→Y（完全）
- 例：(学号,课程号)→成绩

部分函数依赖：
- 定义：Y依赖于X，但X的某个真子集也能决定Y
- 记号：X→Y（部分）
- 例：(学号,课程号)→学生姓名（只需学号）

传递函数依赖：
- 定义：X→Y，Y→Z，则X→Z（Y不是码，Y不依赖于X）
- 记号：X→Y→Z
- 例：学号→系号→系主任

记忆口诀：
完全依赖全靠它，真子集都不能定
部分依赖有冗余，真子集也能决定
传递依赖绕个弯，A到B再到C
```

### 候选键求法（必背）⭐⭐⭐⭐⭐
```
步骤：
1. 找出只在左边出现的属性（必在候选键中）
2. 找出只在右边出现的属性（必不在候选键中）
3. 找出两边都出现的属性（可能在候选键中）
4. 找出两边都不出现的属性（必在候选键中）
5. 计算闭包验证

示例：
U={A,B,C,D,E}
F={AB→C, C→D, D→E, E→B}

分析：
- 只在左边：A（必在候选键）
- 只在右边：无
- 两边都有：B,C,D,E
- 两边都无：无

计算：
A+ = {A}（不够）
AB+ = {A,B,C,D,E}（全部）✓
AC+ = {A,C,D,E,B}（全部）✓

候选键：AB, AC

记忆口诀：
只左必在键中，只右必不在键
两边可能在键，都无必在键中
```

### 无损分解判断（必背）⭐⭐⭐⭐⭐
```
两个关系判断定理：
分解ρ={R1, R2}具有无损连接的充要条件：
(R1∩R2) → (R1-R2) 或 (R1∩R2) → (R2-R1)

即：公共属性能决定其中一个关系的其他属性

示例：
R(A,B,C,D)，F={A→B, C→D}
分解为R1(A,B)和R2(C,D)

R1∩R2 = ∅（空集）
不满足条件，有损分解 ✗

分解为R1(A,B,C)和R2(A,C,D)
R1∩R2 = {A,C}
需要验证：{A,C}→{B}或{A,C}→{D}
由A→B可得{A,C}→{B} ✓
无损分解 ✓

记忆口诀：
公共属性是关键，能否决定其他属性
能决定就无损，不能决定就有损
```

### 事务ACID特性（必背）⭐⭐⭐⭐⭐
```
┌────────┬──────────┬──────────────┐
│特性    │ 英文     │ 含义         │
├────────┼──────────┼──────────────┤
│原子性  │ Atomicity│ 全做或全不做 │
│        │          │ 不可分割     │
├────────┼──────────┼──────────────┤
│一致性  │Consistency│ 数据保持一致│
│        │          │ 完整性约束   │
├────────┼──────────┼──────────────┤
│隔离性  │ Isolation│ 事务间互不   │
│        │          │ 干扰         │
├────────┼──────────┼──────────────┤
│持久性  │Durability│ 提交后永久   │
│        │          │ 保存         │
└────────┴──────────┴──────────────┘

记忆口诀：
原子性全做或不做，一致性数据一致
隔离性互不干扰，持久性永久保存
ACID四特性，事务管理基础
```

### 封锁协议（必背）⭐⭐⭐⭐⭐
```
┌────────┬──────────┬──────────┬──────────┐
│协议    │ 加锁规则 │ 解锁规则 │ 解决问题 │
├────────┼──────────┼──────────┼──────────┤
│一级    │ 修改前加X│ 事务结束 │ 丢失更新 │
│封锁    │          │ 释放     │          │
├────────┼──────────┼──────────┼──────────┤
│二级    │ 一级基础 │ 读完即   │ 丢失更新 │
│封锁    │ 读前加S  │ 释放S    │ 读脏数据 │
├────────┼──────────┼──────────┼──────────┤
│三级    │ 一级基础 │ 事务结束 │ 丢失更新 │
│封锁    │ 读前加S  │ 释放S    │ 读脏数据 │
│        │          │          │ 不可重复读│
└────────┴──────────┴──────────┴──────────┘

锁的类型：
- X锁（排它锁/写锁）：只允许加锁事务读写
- S锁（共享锁/读锁）：允许多个事务读

记忆口诀：
一级修改加X锁，事务结束才释放
二级读前加S锁，读完立即就释放
三级读前加S锁，事务结束才释放
级别越高越安全，解决问题越多
```

### 并发问题（必背）⭐⭐⭐⭐⭐
```
丢失更新（Lost Update）：
- T1修改A并写回
- T2也修改A并写回
- T2覆盖T1的更新
- 解决：一级封锁协议

读脏数据（Dirty Read）：
- T1修改A
- T2读A
- T1回滚
- T2读到的是脏数据
- 解决：二级封锁协议

不可重复读（Non-repeatable Read）：
- T2读A
- T1修改A并提交
- T2再读A，数据不一致
- 解决：三级封锁协议

记忆口诀：
丢失更新两个写，后写覆盖前写
读脏数据读未提交，回滚导致脏数据
不可重复读两次读，中间被修改了
```

### SQL语句分类（必背）⭐⭐⭐⭐⭐
```
DDL（数据定义语言）：
- CREATE：创建表、视图、索引
- ALTER：修改表结构
- DROP：删除表、视图、索引
- TRUNCATE：清空表数据

DML（数据操作语言）：
- SELECT：查询数据
- INSERT：插入数据
- UPDATE：更新数据
- DELETE：删除数据

DCL（数据控制语言）：
- GRANT：授予权限
- REVOKE：撤销权限

TCL（事务控制语言）：
- COMMIT：提交事务
- ROLLBACK：回滚事务
- SAVEPOINT：设置保存点

记忆口诀：
DDL定义结构，CREATE ALTER DROP
DML操作数据，SELECT INSERT UPDATE DELETE
DCL控制权限，GRANT REVOKE
TCL控制事务，COMMIT ROLLBACK
```

## 3.Y 快速记忆口诀大全 ⭐⭐⭐⭐⭐

### 范式判断
```
1NF属性不可分，每个属性都原子
2NF消除部分依赖，非主完全依赖码
3NF消除传递依赖，非主不传递码
BCNF决定因素强，都要包含候选键
范式越高越规范，冗余越少越好
```

### 函数依赖
```
完全依赖全靠它，真子集都不能定
部分依赖有冗余，真子集也能决定
传递依赖绕个弯，A到B再到C
```

### 候选键求法
```
只左必在键中，只右必不在键
两边可能在键，都无必在键中
求出闭包来验证，包含全部就是键
```

### 无损分解
```
公共属性是关键，能否决定其他属性
能决定就无损，不能决定就有损
两个关系看公共，多个关系用表格
```

### ACID特性
```
原子性全做或不做，一致性数据一致
隔离性互不干扰，持久性永久保存
ACID四特性，事务管理基础
```

### 封锁协议
```
一级修改加X锁，事务结束才释放
二级读前加S锁，读完立即就释放
三级读前加S锁，事务结束才释放
级别越高越安全，解决问题越多
```

### 并发问题
```
丢失更新两个写，后写覆盖前写
读脏数据读未提交，回滚导致脏数据
不可重复读两次读，中间被修改了
三个问题三级锁，级别对应来解决
```

### SQL分类
```
DDL定义结构，CREATE ALTER DROP
DML操作数据，SELECT INSERT UPDATE DELETE
DCL控制权限，GRANT REVOKE
TCL控制事务，COMMIT ROLLBACK
```

## 3.Z 典型例题精讲 ⭐⭐⭐⭐⭐

### 例题1：范式判断 ⭐⭐⭐⭐⭐
关系R(学号,课程号,成绩,学分)，其中学分由课程号决定，该关系属于？
A. 1NF  B. 2NF  C. 3NF  D. BCNF

**解析**：
```
分析函数依赖：
- (学号,课程号)→成绩（完全依赖）
- 课程号→学分（部分依赖）
- 候选键：(学号,课程号)
- 主属性：学号、课程号
- 非主属性：成绩、学分

判断：
1. 满足1NF：所有属性都是原子的 ✓
2. 满足2NF？
   - 成绩完全依赖于(学号,课程号) ✓
   - 学分部分依赖于(学号,课程号)，只需课程号 ✗
   - 存在部分函数依赖，不满足2NF

结论：只满足1NF

记忆：
- 有部分依赖 → 只满足1NF
- 无部分依赖，有传递依赖 → 满足2NF
- 无部分依赖，无传递依赖 → 满足3NF
```
**答案**：A

### 例题2：候选键求解 ⭐⭐⭐⭐⭐
关系R(A,B,C,D)，F={A→B, C→D, B→C}，候选键是？
A. A  B. C  C. AC  D. AB

**解析**：
```
步骤1：分析属性出现位置
- 只在左边：A（必在候选键）
- 只在右边：D（必不在候选键）
- 两边都有：B, C
- 两边都无：无

步骤2：计算闭包
A+ = {A, B, C, D}（包含全部属性）✓

步骤3：验证A是否是最小
- A是单个属性，无法再减少
- A+包含全部属性

结论：候选键是A

验证其他选项：
- C+ = {C, D}（不包含A, B）✗
- AC+ = {A, B, C, D}（但A已经够了）
- AB+ = {A, B, C, D}（但A已经够了）
```
**答案**：A

### 例题3：无损分解判断 ⭐⭐⭐⭐⭐
关系R(A,B,C)，F={A→B, B→C}，分解为R1(A,B)和R2(B,C)是否无损？
A. 是  B. 否  C. 不确定  D. 需要更多信息

**解析**：
```
判断无损分解：
R1∩R2 = {B}（公共属性）

需要验证：
B→(A)（R1的其他属性）或 B→(C)（R2的其他属性）

从函数依赖F={A→B, B→C}可知：
B→C ✓（满足条件）

结论：无损分解

记忆：
- 公共属性能决定某个关系的其他属性 → 无损
- 公共属性不能决定任何关系的其他属性 → 有损
```
**答案**：A

### 例题4：封锁协议 ⭐⭐⭐⭐⭐
要解决"不可重复读"问题，至少需要采用哪级封锁协议？
A. 一级  B. 二级  C. 三级  D. 四级

**解析**：
```
封锁协议解决的问题：
一级封锁协议：
- 修改前加X锁，事务结束释放
- 解决：丢失更新

二级封锁协议：
- 一级基础上，读前加S锁，读完即释放
- 解决：丢失更新、读脏数据

三级封锁协议：
- 一级基础上，读前加S锁，事务结束释放
- 解决：丢失更新、读脏数据、不可重复读 ✓

不可重复读的原因：
- T2读A后释放S锁
- T1修改A并提交
- T2再读A，数据不一致

解决方法：
- T2读A后不释放S锁，直到事务结束
- 这样T1无法修改A（需要X锁，与S锁冲突）
- 需要三级封锁协议

记忆：
- 一级：丢失更新
- 二级：丢失更新、读脏数据
- 三级：丢失更新、读脏数据、不可重复读
```
**答案**：C

### 例题5：SQL语句分类 ⭐⭐⭐⭐⭐
以下哪个不是DML语句？
A. SELECT  B. INSERT  C. CREATE  D. DELETE

**解析**：
```
SQL语句分类：

DDL（数据定义语言）：
- CREATE：创建 ✓
- ALTER：修改
- DROP：删除

DML（数据操作语言）：
- SELECT：查询 ✓
- INSERT：插入 ✓
- UPDATE：更新
- DELETE：删除 ✓

DCL（数据控制语言）：
- GRANT：授权
- REVOKE：撤销

CREATE是DDL语句，用于创建表、视图等数据库对象，
不是DML语句。

记忆：
- DDL：定义结构（CREATE, ALTER, DROP）
- DML：操作数据（SELECT, INSERT, UPDATE, DELETE）
- DCL：控制权限（GRANT, REVOKE）
```
**答案**：C
